{ Ver.240826.00 }
unit DataUnit;
{
  '▶' '◀' ① ②  ◎ ◆
  Angle : °, ±kgf·cm
  부하는 IN 으로 무부하는 OUT으로 통일...
}
 
{$INCLUDE myDefine.inc}

interface

uses
    Windows, Sysutils, Graphics, Classes, Messages, FaGraphEx, IniFiles,  Range, Generics.Collections,
    Dialogs, myUtils, KiiMessages, Grids, Global, Forms, ModelType, SeatMotorType, HVTester,
    ExtCtrls, DB, CheckLst, SeatType, DataUnitOrd;


type
    // 통신포트 구별자
    TDevComORD = (dcPS_01);
    TDevCanORD = (dcCAN_01, dcCAN_02);
    TStationID = (st_PWRBurnishing);


    // 검사여부, 실제 검사여부, 결과판정.
    // 검사항목 안에 부가 검사항목이 많을 경우
    // -> 개별 판정에 대한 데이타가 별도 있다면 하나로 명명, 아닐 경우 별도 분리.
       TTsORD     = (
                  tsValidity,
                  tsResult,   //전체판정
                  tsSlide,    // SLIDE
                  tsTilt,   // TILT
                  tsHeight,   // HEIGHT
                  tsCushExt,

                  tsElec,

                  tsIMS_MEM1, // IMS
                  tsIMS_MEM2, // IMS
                  tsIMS_EasyAccess,  // 승하차

                  tsNOISE,    //소음검사여부
                  tsLOAD,     //부하여부   true = Load test
                  tsCURR,     //전류판정여부 반드시 속도와 둘중에 하나는 있어야 한다.
                  tsSPEED,    //속도판정여부

                  tsPoprcv,
                  tsPopsnd,

                  tsDeviation,
                  
                  tsAbnormalSound,   // 이음 판정

                  
                  tsVentNoise,
                  

                  tsLimit,   //가상리미트(IMS사양만)
                  tsLimit_Slide,
                  tsLimit_Tilt,
                  tsLimit_Height,
                  tsLimit_CushExt,

                  tsHeatDrv, tsHeatPsg,
                  tsVentDrv, tsVentPsg, tsBlow,

                  tsBuckle,

                  tsSpecCheck,
                  tsWalkIn,
                  tsAccessory,
                  tsMidPos,
                  
                  tsSp36, tsSP37, tsSP38, tsSP39, tsSP40,
                  tsSP41, tsSP42, tsSP43, tsSP44, tsSP45,
                  tsSP46, tsSP47, tsSP48, tsSP49, tsSP50                  
    ) ;



    TTypeORD = (toUsrType, toDrvType, toSeatType, toImsType, toCarType, toLumbType, toWorkIntype, toHeatTypeDrv, toHeatTypeAss);


    TMsgData = packed record
        mCaption,
        mMsg1,
        mMsg2: string;
        mTime: integer;
        mDlgType: TMsgDlgType;

        procedure Init(Caption, Msg1: string; Msg2: string = '');
    end;


    TTsOrdJudge = packed record
        mTsOrd: TTsORD;
        mJudge: TResultJudge;

        function GetJudgeStr: string;
    end;

    TTsOrdJudgeList = class(TList<TTsOrdJudge>)
    public
        function IndexOf(Item: TTsORD): integer;
        function Add(Item: TTsOrdJudge): integer;
    end;


    { spec }

    PMotorSpec = ^TMotorSpec;
    TMotorSpec = packed record  // sizeof=128
        rCurr: TUserData;
        rSpeedFw: TUserData;
        rSpeedBw: TUserData;
        rTime: TUserData;

        rStroke: double; // 속도 계산을 위한 최대 작동 거리.

        rNoiseInitTime,
        rNoiseInitMax,
        rNoiseRunning,

        rDevNoiseInit,          // 소음 편차
        rDevNoise: Single;
        rBrnCount: Integer;
        rREM: array [0 .. 31] of BYTE;
    end;

    TSpecs = packed record
        rMotors: array[TMotorOrd] of TMotorSpec;
        rHeatOnCurr, rHeatOffCurr,
        rVentOnCurr, rVentOffCurr,
        rBuckleCurr: TUserData;
    end;

    TMotorLimit = packed record
        rTime,
        rCurr: double;
    end;


    TDataSetRWEvent = function (DataSet: TDataSet): boolean of object;

    PModel = ^TModel;
    TModel = packed record // sizeof = 1000
        rIndex: WORD;       // Spec Index를 지정

        rTypes    : TModelType;

        rPartName:  string[50];
        rPartNo:    string[30];
        rLclPartNo: string[30];     // Local PartNo : ex> 포레시아 자체 품번

        rSpecs:     TSpecs;

        rSPITypeBits: DWORD;        // Seat Pin Info TypeBits: 핀정보 객체의 ID(Key)역활

        rREM: array [0 .. 280] of BYTE;

        function IsEmpty: boolean;

        // UI
        procedure Write(Strings: TStrings; StartCol: integer = 0); overload;

        procedure ReadAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
        procedure ReadAsOpt(ChkListBox: TCheckListBox);

        procedure WriteAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
        procedure WriteAsOpt(ChkListBox: TCheckListBox);

        // DB
        procedure Read(DataSet: TDataSet; RWEvent: TDataSetRWEvent = nil);
        function  Write(DataSet: TDataSet; IsAppend: boolean = false; RWEvent: TDataSetRWEvent = nil): boolean; overload;

        function  ToStr(Item: TResultOrd; IsUnit:boolean = false): WideString;
    end;



    TMotorDataBase = packed record
        rTime,
        rCurr: double;
    end;




    PResult = ^TResult;

    TMotorData = packed record // sizeof = 128
        rCurrFw: TMotorDataBase;
        rCurrBw: TMotorDataBase;
        rSpeedFw: double;
        rSpeedBw: double;
        rNoiseInitFw, rNoiseInitBw, rNoiseRunningFw, rNoiseRunningBw: double;
        rDevInitNoiseFw, rDevInitNoiseBw, rDevNoiseFw, rDevNoiseBw: Single;

        rLimit: boolean;

        rREM: array [0 .. 30] of BYTE;

        procedure Clear;
    end;

    TImsData = packed record // sizeof = 16
        rMEM1, rMEM2, rKey: boolean;
        rREM: array [0 .. 12] of BYTE;
    end;

    TMemPosData = packed record
        rOrg, rMove: array [TMotorOrd] of BYTE;
    end;

    THVData = packed record // sizeof = 32
        rOnCurr, rOffCurr: double;
        rLedOffBit, rLedHiBit, rLedMidBit, rLedLoBit: BYTE;
        rIgn: boolean;
        rREM: array [0 .. 10] of BYTE;
    end;


    TResult = packed record // sizeof = 2400

        rValidity: array [TTsORD] of boolean;
        rExists: array [TTsORD] of boolean; // 데이타 유/무.
        rTested: array [TTsORD] of boolean; // 검사대상여부
        rFileTime: double; // 일일작업시간에 의한 일자 + 실제시간
        rLastTime: double; // 실제작업일 + 저장시간. -> Lot No 기준

        rLotNo: string[20];     // Serial
        rPalletNO: string[15];

        rModel: TModel;
        rMcNo: BYTE;


        rDatMtrs: array [TMotorOrd] of TMotorData;
        rDatHVs: array [THVDevType] of THVData;

        rDatNoise: double;

        rDatIMS: TImsData;
        rDatMem1Pos,
        rDatMem2Pos,
        rDatKeyPos: TMemPosData;
        rDatKeyOff: BYTE;

        rCycleTime: double;
        rBCFilePos: integer;        // BCResult File Pos.

        rSeatBCs: string[50];

        rIsRework: boolean;

        rREM: array [0 .. 442] of BYTE;

        procedure Clear(IncModel: boolean = true);

    end;

    // ------------------
    TFaGRAPH_ORD = (faStation1, faStation2);

    pFaGraphEnv = ^TFaGraphEnv;
    pColorList = ^TColorList;
    TColorList = array [0 .. 7] of TColor;

    TFaGraphEnv = packed record // size of 128
        rID: integer;
        rXMax, rXMin, rXStep, rYMax, rYMin, rYStep: double;
        rSpecLine: TColorList; // spec Line
        rDataLine: TColorList; // Data Line
        // rModel   : integer ; // ModelID [1, 2]
        rREM: array [0 .. 11] of BYTE;
    end;

    TSpcEnv = packed record // 36 byte
        rSPCUCL, rSPCLCL, rSPCCL: double;

        rstdXbar: integer; // 군크기...
        rMethod: integer; // 0: Use spec(internal), 1: User Input(External)
        rstdExAver: array [0 .. 7] of boolean;
    end;

      TDeliveryPos  =packed record
            rPos: BYTE; //0 : Forw, 1: Back, 2: Time : 최전방, 최후방, 시간(거리)
            rWay : TMotorWayOrd;

            function GetDir() : TMotorWayOrd;
            function GetTime() : double;
            function InRange(Val : double; Margin :double = 0) : boolean;

            case integer of
                0:
                (
                    rTime : double;  // 시간 또는 거리
                    rMax  : double;
                    rTemp : double

                );
                1:
                 (
                    rMin : double;
                    rMax2   : double;
                    rTemp2 : double
                 );
                2:
                 (
                    rDist : double;
                    rMax3   : double;
                    rTemp3 : double
                 );

            end;    // record 유니온시 end 하나만 !!!   , rTime, rMin, rDist가 같은 공간 다른 이름

    TMotorDeliveryPos = packed record // sizeof 350
        rTypeBits: DWORD;
        rMotors: array [false .. true, 0 .. 3] of TDeliveryPos;
        rMEM2: array [0 .. 2] of TDeliveryPos; // 2013.06.20 승,하차문제로 납품위치를 메모리 위치로 사용함.
        rSelect: boolean; // 2013.06.20 false -> MEM1, true -> MEM2
        rREM: array [0 .. 220] of  BYTE;
    end;




    TUsrCount = packed record
        rTime: double;
        rCount: array [0 .. 1, false .. true] of integer; // 설비번호,양/불
    end;

    

    // Dir & files
    TUsrDir_ORD = (udHOME, udENV, udGRAPH, udRESULT, udTEMP, udSPC, udRS, udDATA, udGRP_DATA, udGRP);

    TUserChs = (ucCurrSlide_Fw, // 전류는 모두 실시간 반영
        ucCurrSlide_Bw, ucSpeedSlide_Fw, // 속도는 결과에만 반영.
        ucSpeedSlide_Bw,

        ucCurrTilt_Fw, ucCurrTilt_Bw, ucSpeedTilt_Fw, ucSpeedTilt_Bw,

        ucCurrHeight_Fw, ucCurrHeight_Bw, ucSpeedHeight_Fw, ucSpeedHeight_Bw,

        ucCurrCushExt_Fw, ucCurrCushExt_Bw, ucSpeedCushExt_Fw,  ucSpeedCushExt_Bw,

        ucNoiseRunning_Slide_Fw, // 소음은 결과 반영
        ucNoiseInit_Slide_Fw, ucNoiseRunning_Slide_Bw, // 소음은 결과 반영
        ucNoiseInit_Slide_Bw,

        ucNoiseRunning_Tilt_Fw, // 소음은 결과 반영
        ucNoiseInit_Tilt_Fw, ucNoiseRunning_Tilt_Bw, // 소음은 결과 반영
        ucNoiseInit_Tilt_Bw,

        ucNoiseRunning_Height_Fw, // 소음은 결과 반영
        ucNoiseInit_Height_Fw, ucNoiseRunning_Height_Bw, // 소음은 결과 반영
        ucNoiseInit_Height_Bw,

        ucNoiseRunning_CushExt_Fw,  //소음은 결과 반영
        ucNoiseInit_CushExt_Fw,

        ucNoiseRunning_CushExt_Bw,  //소음은 결과 반영
        ucNoiseInit_CushExt_Bw,
        ucHeat, ucVent, ucBuckle,

        ucSP28, ucSP29, ucSP30, ucSP31, ucSP32);

    TOffsets = packed record
        rVal: array [TUserChs] of double;
    end;

    TOutPos = packed record
        rType: byte;
        rTime: single;
        rDir4Time: TMotorDir;
    public
        function GetDir() : TMotorDir;
        function GetTime() : single;
    end;


    PModels = ^TModels;
    TModels = packed record // sizeof = 2400
        rIndex:     WORD;

        rTypes:     TModelType;
        rPartName:  string[63];
        rPartNo:    string[63];

        rSpecs: TSpecs;
        rLimits:    array [TMotorOrd] of TMotorLimit;
        rOffsets: array [0 .. 1] of TOffsets; // 설비별 분리

        rOutPos: array[TMotorOrd] of TOutPos;

        rRearSensorIdx: byte;            // 후방 정지 센서 Idx

        rREM: array [0 .. 940] of BYTE;

    end;

    TOutPosInfo = packed record
        mType:          integer;                // 예비용 : 레이저? 끝단?
        mSensorIdx:     integer;                // 사용할 레이저 센서 Idx : 0:#13 1:#14 2: 모두
        mSpec: array [0 .. 1] of TRange;           // 납품위치 레이저 거리 SPEC
        mDirs: array[TMotorOrd] of TMotorDir;     // 모터별 끝단 납품 위치

        function IsIn(Dis1, Dis2: double): boolean;
    end;

    TMdlExData = packed record
        mID:                integer;
        mTypeBits:          DWORD;
        mOutPosInfos: array[TStationID] of TOutPosInfo;

        mSpare: array[0..20] of byte;

        constructor Create(ID: integer; TypeBits: DWORD);
        function Write(FileHandle: integer): boolean;
        function ToKeyStr: string;
    end;


    // --------------------------------
    TTsModeORD = (tw_NONE, tw_INIT, tw_TEST_MODE, tw_POP_LINK_MODE, tw_POP_RCVD_MODEL,
        tw_PDT_LOADED,

        tw_START, tw_STOP, tw_END, tw_SAVE, tw_ARRANGE,

        tw_CON_CHK,
        tw_SPEC_CHK_START, tw_SPEC_CHK_END,
        tw_CHK_DISCONNECT,

        tw_FP_START, tw_FP_END,

        tw_INIT_POS_START, tw_INIT_POS_END,

        tw_CHECK_LOAD_RELEASE,

        tw_MEAS_START, tw_MEAS_STOP,
        tw_BURNISHING_START,  tw_BURNISHING_CYCLE, tw_BURNISHING_END,

        tw_UNLOADING,

        tw_CHECK_ALL_TEST_END,

        tw_DELIVERY_START, tw_DELIVERY_END, tw_DELIVERY_PASS,

        tw_ERROR, tw_EMERGY, tw_ALARM, tw_STATUS, tw_MSG, tw_MSG2,

        tw_POP_PASS, tw_POP_START, tw_POP_END,

        tw_POWER_CHECK,

        tw_OTHER_PROC_END_CHECK,
        // -------------------------------
        // 모터
        tw_MTR_TEST_START, tw_MTR_TEST_STOP,
        tw_LIMIT_START, tw_LIMIT_READED, tw_LIMIT_DONE, tw_MOTOR_INIT,
        // -------------------------------
        // 메모리 검사
        tw_MEMORY_START, tw_MEMORY_END,
        tw_MEM1_PLAY, tw_MEM1_SAVE, tw_MEM1_ARRANGE,
        tw_MEM2_PLAY, tw_MEM2_SAVE, tw_MEM2_ARRANGE,
        tw_KEY_ON, tw_KEY_OFF, tw_KEY_ARRANGE,
        // -------------------------------
        //HV 검사
        tw_HV_TEST_START, tw_HV_STEP_START, tw_HV_STEP_END, tw_HV_TEST_END,
        tw_BLOW_START, tw_BLOW_END,

        tw_FAN_4_NOISE_START, tw_FAN_4_NOISE_END,
        // -------------------------------
        tw_BUCK_TEST_START, tw_BUCK_TEST_END,

        tw_BLUE_LINK,
        tw_HALL_SENSOR,

        tw_ABNML_SOUND, // 이음

        tw_BC_READED,
        tw_MECH_BC_READED,
        tw_PART_BC_READED,
        tw_MID_POS_OK,

        tw_CON_INFO_LOADED,     // 커넥터 정보 읽음

        tw_HIDE_MSG
        );


const
  

    umtWarning = mtWarning;
    umtError = mtError;
    umtInformation = mtInformation;
    umtConfirmation = mtConfirmation;
    umtCustom = mtCustom;

    _CO_SYMBOL = 'DAEWON.CO.LTD,.';

    { Graph Env }
    USR_COLOR = $00E0CBC5;

    ENV_FILE = 'Reference.ini';
    DIR_ENV = '\Env';
    DIR_RESULT = '\Result';
    DIR_SPC = '\SPC';
    DIR_TEMP = '\Temp';
    FILE_GRP = 'graph.env';
    FILE_HW = 'hardware.env';

    NG_TAG = '$';
    OK_TAG = '@';

//    NG_TAG = ' ';
//    OK_TAG = '';

    ARY_TAG: array [false .. true] of string = (NG_TAG, OK_TAG);
    JUDGE_COLOR: array [false .. true] of TColor = (clRed, COLOR_OK);
    JUDGE_COLOR2: array [false .. true] of TColor = (clRed, clBlue);
    JUDGE_TXT: array [false .. true] of string = ('NG', 'OK');
    OnNOff: array [false .. true] of string = ('OFF', 'ON');
    GRP_EXT: array [ord( Low(TFaGRAPH_ORD)) .. ord( High(TFaGRAPH_ORD))] of string =
        ('공정1', '공정2');


    { 그래프 색상 구별 갯수 }
    ARY_DATA_LINE_COUNT: array [TFaGRAPH_ORD] of integer = (4, 4);
    ARY_SPEC_LINE_COUNT: array [TFaGRAPH_ORD] of integer = (4, 4);
    // 스펙 색상 : 2공정, 모터별 4

     DataGridORD : array[0 .. 81] of TResultORD = (
                roIndex,
                roDate,
                roTime,
                roPartName,
                roCarType,
                roWayType,
                roPartNO,
                roLotNo,
                roMcNo,
                roNo,

                roDatRework,

                roRsAbnormalSound,
                //--------------------------
                // Slide
                rospecFwSpeedHiLo,    // ���� �ӵ� ����
                roDataFwSpeed,        // ���� �ӵ�
                rospecBwSpeedHiLo,    // ���� �ӵ� ����
                roDataBwSpeed,        // ���� �ӵ�
                rospecInitNoiseHi,  // �ʱ� ���� ���� ����
                roDataFwInitNoise,    // ���� �ʱ� ����
                roDataBwInitNoise,    // ���� �ʱ� ����
                rospecRunNoiseHi,   // �۵� ���� ����
                roDataFwRunNoise,     // ���� �۵� ����
                roDataBwRunNoise,     // ���� �۵� ����
                rospecCurrHiLo,    // ���� ����
                roDataFwCurr,     // ���� ����
                roDataBwCurr,     // ���� ����
                roRsLimit,

                //--------------------------
                // Tilt
                rospecFwSpeedHiLo,    // ���� �ӵ� ����
                roDataFwSpeed,        // ���� �ӵ�
                rospecBwSpeedHiLo,    // ���� �ӵ� ����
                roDataBwSpeed,        // ���� �ӵ�
                rospecInitNoiseHi,  // �ʱ� ���� ���� ����
                roDataFwInitNoise,    // ���� �ʱ� ����
                roDataBwInitNoise,    // ���� �ʱ� ����
                rospecRunNoiseHi,   // �۵� ���� ����
                roDataFwRunNoise,     // ���� �۵� ����
                roDataBwRunNoise,     // ���� �۵� ����
                rospecCurrHiLo,    // ���� ����
                roDataFwCurr,     // ���� ����
                roDataBwCurr,     // ���� ����
                roRsLimit,

                //--------------------------
                // Height
                rospecFwSpeedHiLo,    // ���� �ӵ� ����
                roDataFwSpeed,        // ���� �ӵ�
                rospecBwSpeedHiLo,    // ���� �ӵ� ����
                roDataBwSpeed,        // ���� �ӵ�
                rospecInitNoiseHi,  // �ʱ� ���� ���� ����
                roDataFwInitNoise,    // ���� �ʱ� ����
                roDataBwInitNoise,    // ���� �ʱ� ����
                rospecRunNoiseHi,   // �۵� ���� ����
                roDataFwRunNoise,     // ���� �۵� ����
                roDataBwRunNoise,     // ���� �۵� ����
                rospecCurrHiLo,    // ���� ����
                roDataFwCurr,     // ���� ����
                roDataBwCurr,     // ���� ����
                roRsLimit,

        //--------------------------
        // LegSupt
        rospecFwSpeedHiLo,    // ���� �ӵ� ����
        roDataFwSpeed,        // ���� �ӵ�
        rospecBwSpeedHiLo,    // ���� �ӵ� ����
        roDataBwSpeed,        // ���� �ӵ�
        rospecInitNoiseHi,  // �ʱ� ���� ���� ����
        roDataFwInitNoise,    // ���� �ʱ� ����
        roDataBwInitNoise,    // ���� �ʱ� ����
        rospecRunNoiseHi,   // �۵� ���� ����
        roDataFwRunNoise,     // ���� �۵� ����
        roDataBwRunNoise,     // ���� �۵� ����
        rospecCurrHiLo,    // ���� ����
        roDataFwCurr,     // ���� ����
        roDataBwCurr,     // ���� ����
        roRsLimit,

        //--------------------------
        // Swivel
        rospecFwSpeedHiLo,    // ���� �ӵ� ����
        roDataFwSpeed,        // ���� �ӵ�
        rospecBwSpeedHiLo,    // ���� �ӵ� ����
        roDataBwSpeed,        // ���� �ӵ�
        rospecInitNoiseHi,  // �ʱ� ���� ���� ����
        roDataFwInitNoise,    // ���� �ʱ� ����
        roDataBwInitNoise,    // ���� �ʱ� ����
        rospecRunNoiseHi,   // �۵� ���� ����
        roDataFwRunNoise,     // ���� �۵� ����
        roDataBwRunNoise,     // ���� �۵� ����
        rospecCurrHiLo,    // ���� ����
        roDataFwCurr,     // ���� ����
        roDataBwCurr,     // ���� ����
        roRsLimit



     );

    PopDataORD: array[0 .. 10] of TResultORD = (

                roIndex, roDate, roTime, roPartNo, roLotNo, roNo,

                roNone, roNone, roNone, roNone,

                // 이음
                roRsAbnormalSound
    ) ;

procedure sysEnvUpdates;



function GetUsrDir(aType: TUsrDir_ORD; aSrc: TDatetime; IsCreate: boolean = true): string; // result is Home\%s\%s...
function GetResultFileName(ATime: TDatetime; IsCreate: boolean = true): string; overload;
function  GetResultFileName(aTime: TDateTime; Ext: string; IsCreate:boolean = true): string; overload;
function GetTempFileName(aName: string; IsCreate: boolean = true): string;
procedure CheckFolder(aDir: string);

function GetOneDayTime(const ATime: TDatetime): TDatetime;
function GetPPM(aOK, aNG: double): double;
function GetOkRate(aOK, aNG: integer): double;
function GetNgRate(aOK, aNG: integer): double;
function IsTxtInList(List: TStrings; const Txt: string): boolean;

function Load(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: integer): boolean;
function Save(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: integer): boolean;

function GetErShowTime: integer;
procedure SetErShowTime(ATime: integer);
// Graph BackGround Image File name
function GetFloatToStr(aValue: double): string; overload;
function GetFloatToStr(aValue: double; aDigit: integer): string; overload;
function GetDipValue(aValue: double): double;
// Count
procedure SetResultReset;
// procedure SetDecCount(AResult: boolean) ;
procedure SetResultCount(Index: integer; AResult: boolean);
function  GetResultCount(Index: integer; AResult: boolean): integer; overload;
// Graph
function IsCpkGraphIndex(AIndex: integer): boolean;
function GetGrpEnv(aGrp: integer): TFaGraphEnv;
function SetGrpEnv(aBuf: TFaGraphEnv): boolean;
function GetGraphLineName(aSection: string; aSubIndex: integer; IsData: boolean): string;
procedure SetGraphLineName(aSection, aName: string; aSubIndex: integer; IsData: boolean);
// Newer
procedure UsrGraphInitial(aGraphEx: TFaGraphEx; gtValue: TGraphType; IsClear: boolean);
procedure SaveGraphDatas(const ATime: double; aGraph: TFaGraphEx);
procedure LoadGraphDatas(const ATime: double; aGraph: TFaGraphEx);

procedure DrawUsrGraphDatas(ATitle: string; ACanvas: TCanvas; ADatas: TPoint; AstdPos: TRect; X, Y: string; AOrd: integer);

procedure SetErrorTxt(ACaption, AError, ATodo: string; DlgType: TMsgDlgType = mtError);

function GetStationName(StationID: TStationID): string;
function GetDevComName(ADevComID: TDevComORD): string;
function GetCompTime(sTime, eTime, ATime: double): boolean;
function GetCanDevName(aDevCanID: TDevCanORD): string;
procedure GetStNamesNCarNames(StNames, CarNames: TStrings);


function GetSeconds(ATime: TDatetime): double;
function GetDateToSec(ATime: TDatetime): double;
function GetTimeToSec(ATime: TDatetime): double;

procedure DrawTLeft(Canvas: TCanvas; X, Y, w, h: integer);
procedure DrawTRight(Canvas: TCanvas; X, Y, w, h: integer);

function SetGraphFileDelete(stdTime: TDatetime): boolean;

function GetMinutes(ATime: TDatetime): double;
function GetDateToMin(ATime: TDatetime): double;
function GetTimeToMin(ATime: TDatetime): double;

procedure SaveGridColWidths(AGrid: TStringGrid; aName: string);
procedure LoadGridColwidths(AGrid: TStringGrid; aName: string);

function ToHexLog(const LogMsg; len: integer): string;



function  LoadDeviceNumber(DevName: string): integer ;
procedure SaveDeviceNumber(DevName: string; Value: integer) ;

// procedure SaveDeliveryPos;

procedure SaveUsrDeliveryPos(const aBuf: TMotorDeliveryPos);
function LoadUsrDeliveryPos(const TypeBits: DWORD): TMotorDeliveryPos;



function JudgeToStr(Dec : TResultJudge) : string;
function BoolToJudge(Val: boolean): TResultJudge;


// ------------------------------------------------------------

function GetTsOrdByResultOrd(ResultOrd: TResultORD): TTsORD;


var
    gMsgData: TMsgData;
    gUsrMsg: HWND = 0;

    // 부하 언로딩 조건-> 1= 검사한다, 2=완료
    // 둘중 하나가 0 이고 나머지는 2이다, 둘다 2이다.
    gTsFuncProc: array [0 .. 1] of BYTE;
    gDioReferwnd: HWND = 0;
    gCycleTime: array [0 .. 1] of double;
    gCanDebugMode: boolean = false;
    gPwrDebugMode: boolean = false;
    gsysRunMode: boolean=false ;

implementation

uses
    Math, StdCtrls, RS232, Log, UserComLibEx, ErrorForm, UserTool,
    DateUtils, ModelUnit, KiiFaGraphDB, DataUnitHelper,  SysEnv, SeatTypeUI, LangTran;

const
    INT_GRP_ENV: TFaGraphEnv = (rXMax: 100; rXMin: 0; rXStep: 20; rYMax: 5; rYMin: 0; rYStep: 1; rSpecLine: ($00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6);
        // spec Line
        rDataLine: (clRed, clBlue, clMaroon, clOlive, clNavy, clPurple, clTeal, clSilver); // Data Line
    );

    INT_SPC_ENV: TSpcEnv = (rSPCUCL: 4; rSPCLCL: 0; rSPCCL: 2; rstdXbar: 2; // 군크기...
        rMethod: 0; );

var
    lpUsrCount: TUsrCount;
    
    lpUsrstdDate: TDatetime = 0;

    // ------------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------------
procedure UsrLogApped(Value: string);
var
    fd: integer;
    yy, mm, dd: WORD;
    sTm: string;
begin
    DecodeDate(Now(), yy, mm, dd);
    sTm := GetUsrDir(udHOME, Now()) + '\LOG\' + Format('%.4d%.2d%.2d.LOG', [yy, mm, dd]);
    if FileExists(sTm) then
        fd := FileOpen(sTm, fmOpenWrite)
    else
        fd := FileCreate(sTm);

    sTm := Value + #13 + #10;
    FileSeek(fd, 0, FILE_END);
    FileWrite(fd, PChar(sTm)^, Length(sTm) * sizeof(Char));
    FileClose(fd);
end;

function GetPPM(aOK, aNG: double): double;
var
    dTm: double;
begin
    // 불량율 : (aNG/aOK)*100
    // PPM    : 불량율 * 100만
    // 2005.06.03
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aNG / dTm) * 1000000;
end;

function GetOkRate(aOK, aNG: integer): double;
var
    dTm: double;
begin
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aOK / dTm) * 100.0;
end;

function GetNgRate(aOK, aNG: integer): double;
var
    dTm: double;
begin
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aNG / dTm) * 100.0;
end;

procedure LoadLastCount;
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), ENV_FILE]);
    Ini := TIniFile.Create(sTm);
    try
        with Ini do
        begin
            lpUsrCount.rCount[0, false] := Ini.ReadInteger('COUNT', '#1 OK', 0);
            lpUsrCount.rCount[0, true] := Ini.ReadInteger('COUNT', '#1 NG', 0);
            lpUsrCount.rCount[1, false] := Ini.ReadInteger('COUNT', '#2 OK', 0);
            lpUsrCount.rCount[1, true] := Ini.ReadInteger('COUNT', '#2 NG', 0);
            lpUsrCount.rTime := Ini.ReadFloat('COUNT', 'TIME', GetOneDayTime(Now()));


        end;
    finally
        Ini.Free;
    end;
end;

procedure SaveCount;
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), ENV_FILE]);
    Ini := TIniFile.Create(sTm);
    try
        with Ini do
        begin
            Ini.WriteInteger('COUNT', '#1 OK', lpUsrCount.rCount[0, false]);
            Ini.WriteInteger('COUNT', '#1 NG', lpUsrCount.rCount[0, true]);
            Ini.WriteInteger('COUNT', '#2 OK', lpUsrCount.rCount[1, false]);
            Ini.WriteInteger('COUNT', '#2 NG', lpUsrCount.rCount[1, true]);
            Ini.WriteFloat('COUNT', 'TIME', lpUsrCount.rTime);

        end;
    finally
        Ini.Free;
    end;
end;

// MainTimer, DataBox save 호출시.
procedure sysEnvUpdates;
begin
    if Trunc(gSysEnv.rOP.rLoadTime) <> Trunc(Now()) then
    begin
        gSysEnv.rOP.rLoadTime := Now;
        gSysEnv.rOP.rLotNo := 0;
        gSysEnv.Save(eiOP);
    end;

    with lpUsrCount do
    begin
        if Trunc(rTime) <> Trunc(GetOneDayTime(Now())) then
        begin
            rTime := GetOneDayTime(Now());
            rCount[0, false] := 0;
            rCount[0, true] := 0;
            rCount[1, false] := 0;
            rCount[1, true] := 0;

            SaveCount();

            SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
            SendToForm(gUsrMsg, SYS_CPK, 0);
        end;
    end;
end;

function GetUsrDir(aType: TUsrDir_ORD; aSrc: TDatetime; IsCreate: Boolean): string;
begin
    case aType of
        udHOME:
            Result := GetHomeDirectory;
        udENV:
            Result := GetUsrDir(udHOME, aSrc) + DIR_ENV;
        udGRAPH:
            Result := GetUsrDir(udRESULT, aSrc) + Format('\%s', [FormatDateTime('yyyymmdd', aSrc)]);
        udRESULT:
            begin
                Result := GetUsrDir(udRS, aSrc, IsCreate);
                Result := Format('%s\%s', [Result, FormatDateTime('yyyymm', aSrc)]);
            end;
        udTEMP:
            Result := GetUsrDir(udHOME, aSrc) + DIR_TEMP;
        udSPC:
            Result := GetUsrDir(udHOME, aSrc) + DIR_SPC;
        udRS:
            Result := GetUsrDir(udDATA, aSrc) + DIR_RESULT;
        udDATA:
            begin
                if gSysEnv.rOP.rResultDir <> '' then
                    Result := string(gSysEnv.rOP.rResultDir)
                else
                    Result := GetUsrDir(udHOME, aSrc);
            end;
        udGRP_DATA:
            begin
                if gSysEnv.rOP.rGraphDir <> '' then
                    Result := string(gSysEnv.rOP.rGraphDir)
                else
                    Result := GetUsrDir(udDATA, aSrc);
            end;
        udGRP:
            Result := GetUsrDir(udGRP_DATA, aSrc) + DIR_RESULT;
    end;

    if IsCreate and not DirectoryExists(Result) then
        ForceDirectories(Result);
end;

function GetTempFileName(aName: string; IsCreate: boolean): string;
begin
    Result := Format('%s\%s', [GetUsrDir(udTEMP, Now(), IsCreate), aName]);
end;

function GetResultFileName(ATime: TDatetime; IsCreate: boolean = true): string;
begin
    Result := Format('%s\%s.dat', [GetUsrDir(udRESULT, ATime, IsCreate), FormatDateTime('yyyymmdd', ATime)]);
end;

function GetResultFileName(aTime: TDateTime; Ext: string; IsCreate:boolean): string;
begin
    Result := Format('%s\%s.%s', [GetUsrDir(udRESULT, aTime, IsCreate),
                                   FormatDateTime('yyyymmdd', aTime), Ext]) ;
end ;

procedure CheckFolder(aDir: string);
var
    i: integer;
    sTm: string;
begin
    sTm := '';
    for i := 1 to Length(aDir) do
    begin
        if (Length(sTm) > 0) and (aDir[i] = '\') and (aDir[i - 1] <> ':') then
            if not DirectoryExists(sTm) then
                ForceDirectories(sTm);

        sTm := sTm + aDir[i];
    end;
end;

function IsCpkGraphIndex(AIndex: integer): boolean;
begin
    Result := false;
    //Result := AIndex In [ord(faCpk1) .. ord(faCpk2)];
end;

function InitGrpEnv(Buf: TFaGraphEnv): TFaGraphEnv;
var
    i: integer;
begin
    Move(Buf, Result, sizeof(TFaGraphEnv));
    with Result do
    begin
        rXMax := 100;
        rXMin := 0;
        rXStep := 10.0;
        rYMax := 100.0;
        rYMin := 0.0;
        rYStep := 10.0;

        for i := 0 to 7 do
        begin
            rSpecLine[i] := INT_GRP_ENV.rSpecLine[i];
            rDataLine[i] := INT_GRP_ENV.rDataLine[i];
        end;
    end;
end;

function LoadGrp(FileHandle, ID: integer; var Buf: TFaGraphEnv): boolean;
begin
    Result := false;
    FileSeek(FileHandle, 0, 0);
    while FileRead(FileHandle, Buf, sizeof(TFaGraphEnv)) = sizeof(TFaGraphEnv) do
    begin
        if Buf.rID = ID then
        begin
            Result := true;
            Break;
        end;
    end;
end;

function GetGrpEnv(aGrp: integer): TFaGraphEnv;
Label _INIT_GRP;
var
    sTm: string;
    fh, iTm: integer;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), FILE_GRP]);

    fh := 0;
    if FileExists(sTm) then
        fh := FileOpen(sTm, fmOpenRead);
    if fh <= 0 then
        Goto _INIT_GRP;

    iTm := FileSeek(fh, 0, 2);
    if (iTm > 0) and ((iTm mod sizeof(TFaGraphEnv)) <> 0) then
    begin
        FileClose(fh);
        RenameFile(sTm, ChangeFileExt(sTm, '.' + FormatDateTime('yymmdd', Now)));
        gLog.ToFiles('GraphEnv File 크기이상 이름변경함.', []);
        Goto _INIT_GRP;
    end;

    if not LoadGrp(fh, aGrp, Result) then
    begin
        FileClose(fh);
        Goto _INIT_GRP;
    end;
    FileClose(fh);
    Exit;

_INIT_GRP :
    Result.rID := aGrp;
    Result := InitGrpEnv(Result);
end;

function SetGrpEnv(aBuf: TFaGraphEnv): boolean;
var
    sTm: string;
    fh, iTm: integer;
    Buf: TFaGraphEnv;
begin
    Result := false;
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), FILE_GRP]);

    if FileExists(sTm) then
        fh := FileOpen(sTm, fmOpenReadWrite)
    else
        fh := FileCreate(sTm);
    if fh <= 0 then
        Exit;

    iTm := FileSeek(fh, 0, 2);
    if (iTm > 0) and ((iTm mod sizeof(TFaGraphEnv)) <> 0) then
    begin
        FileClose(fh);
        RenameFile(sTm, ChangeFileExt(sTm, '.' + FormatDateTime('yymmdd', Now)));
        gLog.ToFiles('GraphEnv File 크기이상 이름변경함.', []);
        fh := FileCreate(sTm);
    end;

    if not LoadGrp(fh, aBuf.rID, Buf) then
        FileSeek(fh, 0, 2)
    else
        FileSeek(fh, -sizeof(TFaGraphEnv), 1);

    Result := FileWrite(fh, aBuf, sizeof(TFaGraphEnv)) = sizeof(TFaGraphEnv);
    FileClose(fh);
end;

function GetOneDayTime(const ATime: TDatetime): TDatetime;
begin
    Result := ATime;
    with gSysEnv do
        if Frac(ATime) < Frac(rOP.rWorkTime) then
            Result := Result - 1;
end;

function IsTxtInList(List: TStrings; const Txt: string): boolean;
var
    i: integer;
begin
    Result := false;
    for i := 0 to List.Count - 1 do
    begin
        if List.Strings[i] = '' then
            Continue;
        if Pos(List.Strings[i], Txt) > 0 then
        begin
            Result := true;
            Break;
        end;
    end;
end;

function Load(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: integer): boolean;
var
    fsLoad: TFileStream;
begin
    Result := false;

    if not FileExists(Filename) then
        Exit;

    fsLoad := TFileStream.Create(Filename, fmOpenRead);
    if fsLoad <> nil then
    begin
        try
            aGraphEx.BeginUpdate();
            aGraphEx.Load(fsLoad, aShareCount);
            aGraphEx.EndUpdate();
        finally
            fsLoad.Free;
            Result := true;
        end;
    end;
end;

function Save(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: integer): boolean;
var
    fsSave: TFileStream;
begin
    Result := false;
    if FileExists(Filename) then
        DeleteFile(Filename);

    fsSave := TFileStream.Create(Filename, fmCreate);
    if fsSave <> nil then
    begin
        try
            aGraphEx.Save(fsSave, aShareCount);
        finally
            fsSave.Free;
            Result := true;
        end;
    end;
end;

function GetErShowTime: integer;
var
    IniFile: TIniFile;
begin
    IniFile := TIniFile.Create(GetIniFiles);
    try
        Result := IniFile.ReadInteger('_ERROR', 'CLOSE_TIME', 360);
    finally
        IniFile.Free;
    end;
end;

procedure SetErShowTime(ATime: integer);
var
    IniFile: TIniFile;
begin
    IniFile := TIniFile.Create(GetIniFiles);
    try
        IniFile.WriteInteger('_ERROR', 'CLOSE_TIME', ATime);
    finally
        IniFile.Free;
    end;
end;

function GetStrToFileName(aTxt: string): string;
var
    i: integer;
begin
    Result := '';
    for i := 1 to Length(aTxt) do
    begin
        if aTxt[i] In ['/', '\', ';', '*', '?', '<', '>', '|'] then
            Result := Result + '-'
        else
            Result := Result + aTxt[i];
    end;
end;

function GetFloatToStr(aValue: double): string;
begin
    Result := GetFloatToStr(aValue, gSysEnv.rOP.rWidth);
end;

function GetFloatToStr(aValue: double; aDigit: integer): string;
var
    i, iTm: integer;
begin
    Result := FloatToStr(aValue);
    if aDigit <= 0 then
        Exit;

    iTm := Pos('.', Result);
    if iTm > 0 then
    begin
        if (Length(Result) - iTm) > aDigit then
        begin
            Result := Copy(Result, 1, iTm + aDigit);
            Exit;
        end
        else
        begin
            iTm := aDigit - (Length(Result) - iTm);
        end;
    end
    else
    begin
        Result := Result + '.';
        iTm := aDigit;
    end;

    for i := 0 to iTm - 1 do
        Result := Result + '0';
end;

function GetFloatToUserData(aValue: Double): Double;
var
    stdUnit: Double;
begin
    stdUnit := Power(10.0, gSysEnv.rOP.rWidth);
    Result := Trunc(stdUnit * aValue) / stdUnit;
end;

function GetDipValue(aValue: Double): Double;
begin
    Result := Round(aValue * Power(10.0, gSysEnv.rOP.rWidth)) / Power(10.0, gSysEnv.rOP.rWidth);
end;

procedure SetResultReset;
begin
    with lpUsrCount do
    begin
        rCount[0, true] := 0;
        rCount[0, false] := 0;
        rCount[1, true] := 0;
        rCount[1, false] := 0;
    end;
    SaveCount();
    SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
end;

procedure SetResultCount(Index: integer; AResult: boolean);
begin
    with lpUsrCount do
    begin
        Inc(rCount[Index, AResult]);
    end;
    SaveCount();
    SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
end;

function GetResultCount(Index: integer; AResult: boolean): integer;
begin
    with lpUsrCount do
        Result := rCount[Index, AResult];
end;

const
    KEY_HEAD: array [false .. true] of string = ('_SPEC', '_DATA');

function GetGraphLineName(aSection: string; aSubIndex: integer; IsData: boolean): string;
var
    Ini: TIniFile;
    sTm, Key: string;
begin
    sTm := Format('%s\GraphLine.env', [GetUsrDir(udENV, Now(), true)]);
    Ini := TIniFile.Create(sTm);
    Key := Format('%s%d', [KEY_HEAD[IsData], aSubIndex]);
    try
        Result := Ini.ReadString(aSection, Key, Copy(Key, 2, Length(Key) - 1));
    finally
        Ini.Free;
    end;
end;

procedure SetGraphLineName(aSection, aName: string; aSubIndex: integer; IsData: boolean);
var
    Ini: TIniFile;
    sTm, Key: string;
begin
    sTm := Format('%s\GraphLine.env', [GetUsrDir(udENV, Now(), true)]);
    Ini := TIniFile.Create(sTm);
    Key := Format('%s%d', [KEY_HEAD[IsData], aSubIndex]);
    try
        Ini.WriteString(aSection, Key, aName);
    finally
        Ini.Free;
    end;
end;

procedure UsrGraphInitial(aGraphEx: TFaGraphEx; gtValue: TGraphType; IsClear: boolean);
    function GetCommaPos(aValue: double; AUnit: integer): WORD;
    var
        i: integer;
        sTm: string;
    begin
        Result := 0;
        if Frac(aValue) = 0 then
            Exit;

        sTm := Format('%0.*f', [AUnit, aValue]);
        sTm := Copy(sTm, Pos('.', sTm) + 1, Length(sTm) - Pos('.', sTm));

        for i := Length(sTm) downto 1 do
        begin
            if sTm[i] <> '0' then
            begin
                Result := i;
                Break;
            end;
        end;
    end;

var
    i: integer;
    grpEnv: TFaGraphEnv;
begin
    try
        with aGraphEx do
        begin
            grpEnv := GetGrpEnv(Tag);

            BeginUpdate();

            GraphType := gtValue;
            Zoom := false;
            // ZoomSerie := 0 ;

            if GraphType = gtNormal then
                GridDraw := [ggHori]//[ggVert, ggHori]
            else
                GridDraw := [ggHori];

            if IsClear then
                Empty();
            // GraphORD, ALine, AIndex
            with Axis do
            begin
                // Items[0].Scale   := asNormal ;
                Items[0].Min := grpEnv.rXMin;
                Items[0].Max := grpEnv.rXMax;
                Items[0].Step := grpEnv.rXStep;
                Items[0].Decimal := GetCommaPos(grpEnv.rXStep, 3);

                // Items[1].Scale   := asNormal ;
                Items[1].Min := grpEnv.rYMin;
                Items[1].Max := grpEnv.rYMax;
                Items[1].Step := grpEnv.rYStep;
                Items[1].Decimal := GetCommaPos(grpEnv.rYStep, 3);

                if (Count > 2) and (Tag In [ord(faStation1), ord(faStation2)]) then
                begin
                    with GetGrpEnv(Tag + 1) do
                    begin
                        Items[2].Min := rYMin;
                        Items[2].Max := rYMax;
                        Items[2].Step := rYStep;
                        Items[2].Decimal := GetCommaPos(rYStep, 3);
                    end;
                end;
            end;

            for i := 0 to Series.Count - 1 do
            begin
                Series.Items[i].Visible := true;
                Series.Items[i].LineColor := grpEnv.rDataLine[i mod 8];
                Series.Items[i].PointColor := Series.Items[i].LineColor;
            end;
            EndUpdate();
        end;
    except
        gLog.ToFiles('EXCEPTION: UsrGraphInitial', []);
    end;
end;

procedure SaveGraphDatas(const ATime: double; aGraph: TFaGraphEx);
begin
    if aGraph.FSdShare.GetMaxIndex(0) <= 0 then
        Exit;
    gKiiDB.Add(ATime, aGraph, aGraph.Series.Count * 2);
end;

procedure LoadGraphDatas(const ATime: double; aGraph: TFaGraphEx);
var
    KiiDB: TKiiGraphDB;
begin
    KiiDB := TKiiGraphDB.Create(stHour, GetUsrDir(udRS, Now(), false));
    try
        KiiDB.Load(ATime, aGraph, aGraph.Series.Count * 2);
    finally
        FreeAndNil(KiiDB);
    end;
end;

procedure DrawUsrGraphDatas(ATitle: string; ACanvas: TCanvas; ADatas: TPoint; AstdPos: TRect; X, Y: string; AOrd: integer);
var
    Tmp: TArrowMark;
    fs: integer;
    sTm: string;
begin
    with ACanvas do
    begin
        SetTextAlign(Handle, TA_CENTER or TA_TOP);
        fs := Font.Size;
        Font.Size := Trunc(fs * 0.9);
        sTm := Format('%s' + #13 + '%s %s', [ATitle, X, Y]);

        case AOrd of
            0:
                Tmp := amTopLeft;
        else
            Tmp := amBottomRight;
        end;

        DrawArrowMark(ACanvas, Tmp, ADatas.X, ADatas.Y, sTm, clNavy, clBlack, true, []);

        Font.Size := fs;
    end;
end;

procedure SetErrorTxt(ACaption, AError, ATodo: string; DlgType: TMsgDlgType);
begin

    if not Assigned(frmError) then
        Exit;

    gMsgData.mCaption := ACaption;
    gMsgData.mMsg1 := AError + #13 + ATodo;
    gMsgData.mTime := GetErShowTime;
    gMsgData.mDlgType := DlgType;

    SendToForm(gUsrMsg, SYS_MSG_ERR, 0);
    {
    try
        frmError.SetFrm(ACaption, AError + #13 + ATodo, GetErShowTime, true, DlgType);
    except
    end;
    }
end;



function GetDevComName(ADevComID: TDevComORD): string;
begin
    case ADevComID of
        dcPS_01:
            Result := 'Pwr.Sply1';


    else
        Result := '';
    end;
end;

function GetCanDevName(aDevCanID: TDevCanORD): string;
begin
    case aDevCanID of
        dcCAN_01:
            Result := 'CAN#1';
    else
        Result := 'CAN#2';
    end;
end;

function GetCompTime(sTime, eTime, ATime: double): boolean;
begin
    sTime := Frac(sTime);
    eTime := Frac(eTime);
    ATime := Frac(ATime);

    if sTime < eTime then
        Result := (sTime <= ATime) and (ATime <= eTime)
    else
        Result := not((eTime <= ATime) and (ATime <= sTime));
end;

function GetTimeToSec(ATime: TDatetime): double;
var
    hh, nn, ss, zz: WORD;
begin
    Result := ATime;

    DecodeTime(Result, hh, nn, ss, zz);
    Result := hh * 3600;
    Result := Result + (nn * 60);
    Result := Result + ss;
    Result := Result + (Round(zz / 100) / 10);
end;

function GetDateToSec(ATime: TDatetime): double;
begin
    Result := ATime;
    Result := Trunc(Result) * SecsPerDay;
end;

function GetSeconds(ATime: TDatetime): double;
begin
    Result := ATime;
    if Result <= 0 then
    begin
        Result := 0;
        Exit;
    end
    else if (Result > 0) and (Result < 1) then
    begin
        Result := GetTimeToSec(ATime);
    end
    else
    begin
        Result := GetTimeToSec(ATime) + GetDateToSec(ATime);
    end;
end;

procedure DrawTLeft(Canvas: TCanvas; X, Y, w, h: integer);
begin
    with Canvas do
    begin
        w := (w shr 1) shl 1;
        h := (h shr 1) shl 1;

        Polygon([Point(X - w, Y), Point(X + w, Y - h), Point(X + w, Y + h)]);
    end;
end;

procedure DrawTRight(Canvas: TCanvas; X, Y, w, h: integer);
begin
    with Canvas do
    begin
        w := (w shr 1) shl 1;
        h := (h shr 1) shl 1;

        Polygon([Point(X + w, Y), Point(X - w, Y - h), Point(X - w, Y + h)]);
    end;
end;

function GetOldestFolder(Astd, ADest: string): string;
var
    sTm: string;
    done: integer;
    srFile: TSearchRec;
begin
    Result := Astd;
    done := Sysutils.FindFirst(ADest + '\*.*', faDirectory, srFile);
    try
        while done = 0 do
        begin
            if (srFile.Name[1] <> '.') and ((srFile.Attr and faDirectory) = faDirectory) then
            begin
                sTm := ADest + '\' + srFile.Name;
                if Length(Astd) <> Length(sTm) then
                begin
                    sTm := GetOldestFolder(Astd, sTm);
                end;

                if Result > sTm then
                begin
                    Result := sTm;
                end;
            end;
            done := Sysutils.FindNext(srFile);
        end;
    finally
        Sysutils.FindClose(srFile);
    end;
end;

function SetGraphFileDelete(stdTime: TDatetime): boolean;
var
    sTm, grpFile, Dest: string;
    KiiDB: TKiiGraphDB;
begin
    Result := false;
    sTm := GetUsrDir(udGRP, stdTime, false);
    if not DirectoryExists(sTm) then
        Exit;

    try
        KiiDB := TKiiGraphDB.Create(stHour, GetUsrDir(udGRP, Now, true));
        grpFile := KiiDB.GetGraphFileName(stdTime, false);
        Dest := GetOldestFolder(ExtractFileDir(grpFile), sTm);
        if Dest = ExtractFileDir(grpFile) then
            Exit;
        Zap(Dest);
        gLog.ToFiles('start Del old graph file: %s', [Dest]);
        RemoveDir(Dest);
        gLog.ToFiles('end Del old graph file: %s', [Dest]);
    finally
        FreeAndNil(KiiDB);
    end;
    Result := true;
end;

function GetTimeToMin(ATime: TDatetime): double;
var
    hh, nn, ss, zz: WORD;
begin
    Result := ATime;

    DecodeTime(Result, hh, nn, ss, zz);
    Result := hh * 60;
    Result := Result + nn;
    if ss > 0 then
    begin
        nn := Length(IntToStr(ss));
        Result := Result + ss / Power(10, nn);
    end
    else
        Result := Result; ;
end;

function GetDateToMin(ATime: TDatetime): double;
begin
    Result := ATime;
    Result := Trunc(Result) * MinsPerDay;
end;

function GetMinutes(ATime: TDatetime): double;
begin
    Result := ATime;
    if Result <= 0 then
    begin
        Result := 0;
        Exit;
    end
    else if (Result > 0) and (Result < 1) then
    begin
        Result := GetTimeToMin(ATime);
    end
    else
    begin
        Result := GetTimeToMin(ATime) + GetDateToMin(ATime);
    end;
end;

procedure SaveGridColWidths(AGrid: TStringGrid; aName: string);
var
    i: integer;
    sTm: string;
begin
    sTm := Format('%s\GridWidths.env', [GetUsrDir(udENV, Now, false)]);
    with TIniFile.Create(sTm) do
    begin
        try
            for i := 0 to AGrid.ColCount - 1 do
            begin
                WriteInteger(aName, 'COL_' + IntToStr(i), AGrid.ColWidths[i]);
            end;
        finally
            Free;
        end;
    end;
end;

procedure LoadGridColwidths(AGrid: TStringGrid; aName: string);
var
    i: integer;
    sTm: string;
begin
    sTm := Format('%s\GridWidths.env', [GetUsrDir(udENV, Now, false)]);
    if not FileExists(sTm) then
        Exit;
    with TIniFile.Create(sTm) do
    begin
        try
            for i := 0 to AGrid.ColCount - 1 do
            begin
                AGrid.ColWidths[i] := ReadInteger(aName, 'COL_' + IntToStr(i), 100);
            end;
        finally
            Free;
        end;
    end;
end;

function ToHexLog(const LogMsg; len: integer): string;
var
    i: integer;
begin
    Result := '';
    for i := 0 to len - 1 do
        Result := Result + IntToHex(TByteArray(LogMsg)[i], 2) + ' ';
end;

function GetStationName(StationID: TStationID): string;
begin
    {
    if gSysEnv.rStGroupNo <= 1 then
        Result := Format('#%d', [gSysEnv.rStNo + Ord(StationID)])
    else
        Result := Format('#%d-%d', [gSysEnv.rStNo + Ord(StationID), gSysEnv.rStGroupNo - 1]);
    }
    Result := Format('%dth', [gSysEnv.rOP.rStNo + Ord(StationID)]);
    //Result := '';
end;

procedure GetStNamesNCarNames(StNames, CarNames: TStrings);
var
    i: Integer;
    j: TCAR_TYPE;

begin
    if StNames <> nil then
    begin
        StNames.Clear;
        for i := 0 to MAX_ST_COUNT - 1 do
        begin
            StNames.Add(GetStationName(TStationID(i)));
        end;
    end;

    if CarNames <> nil then
    begin
        CarNames.Clear;
        for j := Low(TCAR_TYPE) to High(TCAR_TYPE) do
        begin
            CarNames.Add(TCAR_TYPE_STR[Ord(j)]);
        end;

    end;
end;



procedure SaveUsrDeliveryPos(const aBuf: TMotorDeliveryPos);
var
    sTm: string;
    fh, iDx: integer;
    Buf: TMotorDeliveryPos;
begin
    iDx := 0;
    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if FileExists(sTm) then
    begin
        fh := FileOpen(sTm, fmOpenRead);
        try
            while FileRead(fh, Buf, sizeof(TMotorDeliveryPos)) = sizeof(TMotorDeliveryPos) do
            begin
                if Buf.rTypeBits = aBuf.rTypeBits then
                begin
                    iDx := FileSeek(fh, 0, 1) div sizeof(TMotorDeliveryPos);
                    Break;
                end;
            end;
        finally
            FileClose(fh);
        end;
    end;

    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if not FileExists(sTm) then
        fh := FileCreate(sTm)
    else
        fh := FileOpen(sTm, fmOpenWrite);
    try
        if iDx > 0 then
            FileSeek(fh, (iDx - 1) * sizeof(TMotorDeliveryPos), 0)
        else
            FileSeek(fh, 0, 2);
        FileWrite(fh, aBuf, sizeof(TMotorDeliveryPos));
    finally
        FileClose(fh);
    end;
end;

function LoadUsrDeliveryPos(const TypeBits: DWORD): TMotorDeliveryPos;
var
    sTm: string;
    fh: integer;
begin
    FillChar(Result, sizeof(TMotorDeliveryPos), 0);
    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if FileExists(sTm) then
    begin
        fh := FileOpen(sTm, fmOpenRead);
        try
            while FileRead(fh, Result, sizeof(TMotorDeliveryPos)) = sizeof(TMotorDeliveryPos) do
            begin
                if Result.rTypeBits = TypeBits then
                    Break
                else
                    Result.rTypeBits := 0;
            end;
        finally
            FileClose(fh);
        end;
    end;

    if Result.rTypeBits = 0 then
    begin
        Result.rTypeBits := TypeBits;
        Result.rMotors[false, 0].rPos := 0;
        Result.rMotors[false, 0].rTime := 2.0;
        Result.rMotors[false, 1].rPos := 0;
        Result.rMotors[false, 1].rTime := 2.0;
        Result.rMotors[false, 2].rPos := 0;
        Result.rMotors[false, 2].rTime := 2.0;

        Result.rMotors[true, 0].rPos := 0;
        Result.rMotors[true, 0].rTime := 2.0;
        Result.rMotors[true, 1].rPos := 0;
        Result.rMotors[true, 1].rTime := 2.0;
        Result.rMotors[true, 2].rPos := 0;
        Result.rMotors[true, 2].rTime := 2.0;
    end;
end;

function GetTsOrdByResultOrd(ResultOrd: TResultORD): TTsORD;
begin
//    case ResultOrd of
//        // H/V
//          roDatHeatOnCurrDrv,
//          roRsHeatOnDrv,
//          roDatHeatOffCurrDrv,
//          roRsHeatOffDrv,
//          roDatHeatLedOffBitDrv,
//          roDatHeatLedHiBitDrv,
//          roDatHeatLedMidBitDrv,
//          roDatHeatLedLoBitDrv,
//          roRsHeatLedOffDrv,
//          roRsHeatLedHiDrv,
//          roRsHeatLedMidDrv,
//          roRsHeatLedLoDrv,
//          roRsHeatLedDrv,
//          roRsHeatIgnDrv,
//          roRsHeatDrv:
//          begin
//            Result := tsHeatDrv;
//          end;
//
//
//          roDatHeatOnCurrAss,
//          roRsHeatOnAss,
//          roDatHeatOffCurrAss,
//          roRsHeatOffAss,
//          roDatHeatLedOffBitAss,
//          roDatHeatLedHiBitAss,
//          roDatHeatLedMidBitAss,
//          roDatHeatLedLoBitAss,
//          roRsHeatLedOffAss,
//          roRsHeatLedHiAss,
//          roRsHeatLedMidAss,
//          roRsHeatLedLoAss,
//          roRsHeatLedAss,
//          roRsHeatIgnAss,
//          roRsHeatAss,
//          roRsHeat:
//          begin
//            Result := tsHeatPsg;
//          end;
//
//
//          roDatVentOnCurrDrv,
//          roRsVentOnDrv,
//          roDatVentOffCurrDrv,
//          roRsVentOffDrv,
//          roDatVentLedOffBitDrv,
//          roDatVentLedHiBitDrv,
//          roDatVentLedMidBitDrv,
//          roDatVentLedLoBitDrv,
//          roRsVentLedOffDrv,
//          roRsVentLedHiDrv,
//          roRsVentLedMidDrv,
//          roRsVentLedLoDrv,
//          roRsVentLedDrv,
//          roRsVentIgnDrv,
//          roRsVentDrv:
//          begin
//            Result := tsVentDrv;
//          end;
//
//          roDatVentOnCurrAss,
//          roRsVentOnAss,
//          roDatVentOffCurrAss,
//          roRsVentOffAss,
//          roDatVentLedOffBitAss,
//          roDatVentLedHiBitAss,
//          roDatVentLedMidBitAss,
//          roDatVentLedLoBitAss,
//          roRsVentLedOffAss,
//          roRsVentLedHiAss,
//          roRsVentLedMidAss,
//          roRsVentLedLoAss,
//          roRsVentLedAss,
//          roRsVentIgnAss,
//          roRsVentAss,
//          roRsVent:
//          begin
//              Result := tsVentPsg;
//          end;
//
//          roDatOffBlow,
//          roRsOffBlow,
//          roDatOnBlow,
//          roRsOnBlow:
//          begin
//              Result := tsBlow;
//          end;
//
//
//        // 모터
//        roDataTimeFw_Slide, // 최대전류 값의 시간
//        roDataCurrFw_Slide, // 최대전류
//        roDataSpeedFw_Slide,
//        roDataTimeBw_Slide,
//        roDataCurrBw_Slide,
//        roDataSpeedBw_Slide,
//        roRsSLIDE_Fw,
//        roRsSLIDE_Bw:
//            begin
//                Result := tsSlide;
//            end;
//
//        roDataTimeFw_Tilt,
//        roDataCurrFw_Tilt,
//        roDataSpeedFw_Tilt,
//        roDataTimeBw_Tilt,
//        roDataCurrBw_Tilt,
//        roDataSpeedBw_Tilt,
//        roRsTilt_Fw,
//        roRsTilt_Bw:
//            begin
//                Result := tsTilt;
//            end;
//
//        roDataTimeFw_Height,
//        roDataCurrFw_Height,
//        roDataSpeedFw_Height,
//        roDataTimeBw_Height,
//        roDataCurrBw_Height,
//        roDataSpeedBw_Height,
//        roRsHeight_Fw,
//        roRsHeight_Bw:
//            begin
//                Result := tsHeight;
//            end;
//
//        roDataTimeFw_CushExt,
//        roDataCurrFw_CushExt,
//        roDataSpeedFw_CushExt,
//        roDataTimeBw_CushExt,
//        roDataCurrBw_CushExt,
//        roDataSpeedBw_CushExt,
//        roRsCushExt_Fw,
//        roRsCushExt_Bw:
//            begin
//                Result := tsCushExt;
//            end;
//
//        // 소음
//
//        roRsNoise:
//            begin
//                Result := tsNOISE;
//            end;
//
//
//        roDatBuckle, roRsBuckle:
//            Result := tsBuckle;
//
//
//        // IMS
//
//        roRsLimit_Slide : Result := tsLimit_Slide;
//        roRsLimit_Tilt : Result := tsLimit_Tilt;
//        roRsLimit_Height: Result := tsLimit_Height;
//        roRsLimit_CushExt: Result := tsLimit_CushExt;
//
//        roRsMem1: Result := tsIMS_MEM1;
//        roRsMem2: Result := tsIMS_MEM2;
//        roRsEasyAccess: Result := tsIMS_EasyAccess;
//
//        roRsMidPos : Result := tsMidPos;
//
//        //
//
//        roRsElec: Result := tsElec;
//
//    else
//        Result := tsSp42; // High(TTsOrd);;
//        gLog.Debug('func GetTsOrdByResultOrd(%s) 없음', [GetResultOrdName(ResultOrd)]);
//    end;
end;




function  LoadDeviceNumber(DevName: string): integer ;
var
    sTm : string ;
    Ini : TIniFile ;
begin
    sTm := Format('%s\DeviceInfo.ini', [GetUsrDir(udENV, Now())]);
    Ini := TIniFile.Create(sTm) ;
    try
        Result:= Ini.ReadInteger(DevName, 'DEV NUMBER', 0) ;
        if not Ini.SectionExists(DevName) then
        begin
            Ini.WriteInteger(DevName, 'DEV NUMBER', Result);
        end;
    finally
        Ini.Free ;
    end ;
end;

procedure SaveDeviceNumber(DevName: string; Value: integer) ;
var
    sTm : string ;
    Ini : TIniFile ;
begin
    sTm := Format('%s\DeviceInfo.ini', [GetUsrDir(udENV, Now())]);
    Ini := TIniFile.Create(sTm) ;
    try
        Ini.WriteInteger(DevName, 'DEV NUMBER', Value) ;
    finally
        Ini.Free ;
    end ;
end;


function JudgeToStr(Dec : TResultJudge) : string;
begin
    case Dec of
        rjNone: Result := 'None';
        rjOK: Result := JUDGE_TXT[true];
        rjNG: Result := JUDGE_TXT[false];
    end;

end;

function BoolToJudge(Val: boolean): TResultJudge;
begin
    if Val then Exit(rjOK);

    Exit(rjNG);
end;


//------------------------------------------------------------------------------
{ TDeliveryPos }

function TDeliveryPos.GetDir: TMotorWayOrd;
begin
    case rPos of
        0: Result := twForw;
        1: Result := twBack;
        2: Result := rWay;
    end;
end;

function TDeliveryPos.InRange(Val, Margin: double): boolean;
begin
    Result := ((rMin - Margin) <= Val) and (Val <= (rMax + Margin));
end;

function TDeliveryPos.GetTime : double;
begin
    case rPos of
        0: Result := 0;
        1: Result := 0;
        2: Result := rTime;
    end;
end;


{ TModel }

function TModel.IsEmpty: boolean;
begin
    Result := rIndex <= 0;
end;

procedure TModel.Read(DataSet: TDataSet; RWEvent: TDataSetRWEvent);
begin
    rIndex := 0;            // Spec 설정 유무용 Flag로 사용

    rPartNo := DataSet.FieldByName('part_no').AsString;
    rLclPartNo := DataSet.FieldByName('lcl_part_no').AsString;
    rPartName := DataSet.FieldByName('part_name').AsString;
    rTypes.mDataBits := DataSet.FieldByName('type_bits').AsLargeInt;
    rSPITypeBits := DataSet.FieldByName('spi_type_bits').AsLargeInt;

    if Assigned(RWEvent) then
        RWEvent(DataSet);
end;

procedure TModel.ReadAsOpt(ChkListBox: TCheckListBox);
begin
    SeatTypeUI.ReadAsOpt(rTypes, ChkListBox);
end;

procedure TModel.ReadAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
begin
    //SeatTypeUI.ReadAsType(rTypes, PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG);
end;

function TModel.ToStr(Item: TResultOrd; IsUnit:boolean=false): WideString;
begin
    Result := GetModelToTxt(Self, Ord(Item), IsUnit);
end;


function TModel.Write(DataSet: TDataSet; IsAppend: boolean; RWEvent: TDataSetRWEvent): boolean;
begin
    Result := true;
    try

        if IsAppend then
            DataSet.Append
        else
            DataSet.Edit;

        DataSet.FieldByName('part_no').AsString := rPartNo;
        DataSet.FieldByName('lcl_part_no').AsString := rLclPartNo;
        DataSet.FieldByName('part_name').AsString := rPartName;
        DataSet.FieldByName('type_bits').AsLargeInt := rTypes.mDataBits;
        DataSet.FieldByName('spi_type_bits').AsLargeInt := rSPITypeBits;

        if Assigned(RWEvent) then
        begin
            if not RWEvent(DataSet) then
            begin
                Exit(false);
            end;
        end;


        DataSet.Post;

        if IsAppend then
            DataSet.Last;

    except
        on e: EDatabaseError   do
        begin
            gLog.Panel(e.ToString);
            ShowMessage(e.ToString);
            DataSet.Cancel;
            Exit(false);
        end;
    end;

end;

procedure TModel.Write(Strings: TStrings; StartCol: integer);
var
    MT: TModelType;
begin
    Strings.Strings[StartCol + 0] := rPartNo;
    Strings.Strings[StartCol + 1] := rLclPartNo;
    rTypes.WriteAsType(Strings, 2);
end;

procedure TModel.WriteAsOpt(ChkListBox: TCheckListBox);
begin
    SeatTypeUI.WriteAsOpt(rTypes, ChkListBox);
end;

procedure TModel.WriteAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
begin
    //SeatTypeUI.WriteAsType(rTypes, PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG);
end;

{ TMotorData }

procedure TMotorData.Clear;
begin
    rCurrFw.rCurr:= -999 ;
    rCurrBw.rCurr:= -999 ;
    rSpeedFw:= 999 ;
    rSpeedBw:= 999 ;
    rNoiseInitFw:= 999 ;
    rNoiseInitBw:= 999 ;
    rNoiseRunningFw:= 999 ;
    rNoiseRunningBw:= 999 ;
    rDevInitNoiseFw:= 999 ;
    rDevInitNoiseBw:= 999 ;
    rDevNoiseFw:= 999 ;
    rDevNoiseBw:= 999 ;
    rLimit := false;
end;



{ TMsgData }

procedure TMsgData.Init(Caption, Msg1, Msg2: string);
begin
    mCaption := Caption;
    mMsg1 := Msg1;
    mMsg2 := Msg2;
end;

{ TMdlExData }

constructor TMdlExData.Create(ID: integer; TypeBits: DWORD);
begin
    mID := ID;
    mTypeBits := TypeBits;
end;

function TMdlExData.ToKeyStr: string;
begin
    Result := Format('%d.%X', [mID, mTypeBits]);
end;

function TMdlExData.Write(FileHandle: integer): boolean;
begin
    Result := FileWrite(FileHandle, self, sizeof(TMdlExData)) = sizeof(TMdlExData);
end;


{ TTsOrdJudge }

function TTsOrdJudge.GetJudgeStr: string;
begin
    Result := JudgeToStr(mJudge);
end;

{ TTsOrdJudgeList }

function TTsOrdJudgeList.Add(Item: TTsOrdJudge): integer;
begin
    Result := inherited Add(Item);
end;

function TTsOrdJudgeList.IndexOf(Item: TTsORD): integer;
var
    i: integer;
begin
    for i := 0 to Self.Count - 1 do
    begin
        if Items[i].mTsOrd = Item then
            Exit(i);
    end;

    Result := -1;
end;



{ TResult }

procedure TResult.Clear(IncModel: boolean);
var
    TempMdl: TModel;
begin

    Move(rModel, TempMdl, sizeof(TModel));
    ZeroMemory(@self, sizeof(TResult)) ;

    if not IncModel then
        Move(TempMdl, RModel, sizeof(TModel));

    rBCFilePos := -1;
end;


{ TOutPosInfo }

function TOutPosInfo.IsIn(Dis1, Dis2: double): boolean;
begin
    case mSensorIdx of
        0:
            Result := mSpec[0].IsIn(Dis1);
        1:
            Result := mSpec[1].IsIn(Dis2);
        2:
            Result := mSpec[0].IsIn(Dis1) or mSpec[1].IsIn(Dis2);
        3:
            Result := mSpec[0].IsIn(Dis1) and mSpec[1].IsIn(Dis2);
    else
        Result := mSpec[0].IsIn(Dis1);
    end;
end;

{ TOutPos }

function TOutPos.GetDir: TMotorDir;
begin
    case rType of
        0:  Result := twForw;
        1:  Result := twBack;
        2:  Result := rDir4Time;
    else
        Result := twBack;
    end;
end;

function TOutPos.GetTime: single;
begin
    case rType of
        2:  Result := rTime;
    else
        Result := 0.0;
    end;

end;

Initialization
    gSysEnv.LoadAll;

    gSysEnv.rOP.rVer := '250626.00';

    TLangTran.Init(ltKor, TLangType(gSysEnv.rOP.rLanguage));

{$IFNDEF _VIEWER}
    lpUsrstdDate := EncodeDate(2014, 06, 01);
    LoadLastCount;
    


    // LoadDeliveryPos ;
    gCycleTime[0] := 0;
    gCycleTime[1] := 0;


{$ENDIF}

end.
