{ Ver.250618.00 }
unit DataUnit;

{$INCLUDE myDefine.inc}

interface

uses
    Windows, Sysutils, Graphics, Classes, Messages, FaGraphEx, IniFiles, Range,
    Generics.Collections, Dialogs, myUtils, KiiMessages, Grids, Global, Forms,
    ModelType, SeatMotorType, HVTester, ExtCtrls, DB, CheckLst, SeatType, Spec,
    DataUnitOrd;

type
    // ?????? ??????
    TDevComORD = (dcPS_01);

    TDevCanORD = (dcCAN_01, dcCAN_02);

    TStationID = (st_PWRBurnishing);

    TMsgData = packed record
        mCaption, mMsg1, mMsg2: string;
        mTime: Integer;
        mDlgType: TMsgDlgType;

        procedure Init(Caption, Msg1: string; Msg2: string = '');
    end;

    TTsOrdJudge = packed record
        mTsOrd: TTsORD;
        mJudge: TResultJudge;

        function GetJudgeStr: string;
    end;

    TTsOrdJudgeList = class(TList<TTsOrdJudge>)
    public
        function IndexOf(Item: TTsORD): Integer;
        function Add(Item: TTsOrdJudge): Integer;
    end;





{==============================================================================}
{   Spec                                                                       }
{==============================================================================}

    PMotorSpec = ^TMotorSpec;

    TMotorSpec = packed record  // sizeof=100
        rTime, rCurr: TSpec;

        rSpeed, rPos: array[TMotorDir] of TSpec; // ??????, ??? ???? ????? ???..


        rInitNoiseTime, rInitNoise,        // ?????? Max (????.)
        rRunNoise, rInitNoiseDev, rRunNoiseDev: Single;              // ???? ????

        rBrnCount: Integer;

        rREM: array[0..27] of BYTE;

        procedure Init;
    end;

    TSpecs = packed record
        rMotors: array[TMotorOrd] of TMotorSpec;
        rOnCurr: array[THVTestType] of TSpec;
        rOffCurr: array[THVTestType] of TSpec;

        rBuckleCurr: TSpec;
        rAncPTReg: TSpec; // ??¨¨PT ????

        rHeatOnCurr, rHeatOffCurr, rVentOnCurr, rVentOffCurr: TSpec;

        procedure Init;

        function ToMotorStr(MtrOrd: TMotorOrd; RO: TResultOrd; IsUnit: Boolean = False): string; overload;
    end;

    // ???? ?????  ???? ????, ?©£?, ???, ????????
    PMotorConstraints = ^TMotorConstraints;

    TMotorConstraints = packed record
        rMaxTime: Single; // ??? ????? ?©£?
        rStroke: Single; // ??? ????? ???? ??? ??? ???.

        rMethodIdx: Byte;

        function IsMoveByTime: Boolean;

        case Integer of
            0:
                (rLockedCurr: Single;
                rOperTIme: Single;);
            1:
                (mOperItems: array[0..1] of Single;)

    end;

    TDataSetRWEvent = function(DataSet: TDataSet): Boolean of object;


{==============================================================================}
{   Model                                                                      }
{==============================================================================}

    PModel = ^TModel;

    TModel = packed record // sizeof = 1000
        rIndex: WORD;       // Spec Index?? ????

        rTypes: TModelType;

        rPartName: string[50];
        rPartNo: string[30];
        rLclPartNo: string[30];     // Local PartNo : ex> ?????©­? ??? ???

        rSpecs: TSpecs;

        rSPITypeBits: DWORD;        // Seat Pin Info TypeBits: ?????? ????? ID(Key)???

        rREM: array[0..280] of BYTE;

        function IsEmpty: Boolean;

        // UI
        procedure Write(Strings: TStrings; StartCol: Integer = 0); overload;

        procedure ReadAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
        procedure ReadAsOpt(ChkListBox: TCheckListBox);

        procedure WriteAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
        procedure WriteAsOpt(ChkListBox: TCheckListBox);

        // DB
        procedure Read(DataSet: TDataSet; RWEvent: TDataSetRWEvent = nil);
        function Write(DataSet: TDataSet; IsAppend: Boolean = False; RWEvent: TDataSetRWEvent = nil): Boolean; overload;

    end;




{==============================================================================}
{   ???? Data                                                                  }
{==============================================================================}

    PResult = ^TResult;

    TMotorTestItem = packed record
        rTime, rCurr, rSpeed, rInitNoise, rRunNoise, rInitNoiseDev, rRunNoiseDev: Single;  // ????

        rREM: array[0..10] of BYTE;
    end;

    TMotorData = packed record // sizeof = 128
        rItems: array[TMotorDir] of TMotorTestItem;
        rLimit: Boolean;
        rREM: array[0..30] of BYTE;
        procedure Clear;

    end;

    TImsData = packed record // sizeof = ??
        rMem1, rMem2, rMem3, rKey: Boolean;
        rREM: array[0..12] of BYTE;
    end;

    TMemPosData = packed record
        rOrg, rMove: array[TMotorOrd] of Integer;
    end;

    THVData = packed record // sizeof = ??
        rOnCurr, rOffCurr: Single;
        rLedOffBit, rLedHiBit, rLedMidBit, rLedLoBit: BYTE;
        rIgn: Boolean;
        rREM: array[0..10] of BYTE;
    end;

    TEcuInfo = packed record
        rPartNo: string[20];
        rSwVer: string[20];
        rHwVer: string[20];

        constructor Create(const APartNo, ASwVer, AHwVer: string);

        function ToStr: string;
        function Equals(const Other: TEcuInfo): Boolean;

        function ComparePartNo(const Target: string): Boolean;
        function CompareSwVer(const Target: string): Boolean;
        function CompareHwVer(const Target: string): Boolean;
    end;

    THVDatas = array[THVPosType, THVTestType] of THVData;

    TResult = packed record // sizeof = ??

        rValidity: array[TTsORD] of Boolean; // ???? ??/?? ???
        rExists: array[TTsORD] of Boolean; // ????? ??/??.
        rTested: array[TTsORD] of Boolean; // ??????
        rFileTime: Double; // ????????©£??? ???? ???? + ?????©£?
        rLastTime: Double; // ????????? + ????©£?. -> Lot No ????

        rLotNo: string[20];     // Serial
        rPalletNO: string[15];

        rModel: TModel;
        rMcNo: BYTE;

        rCurMtr: TMotorOrd;
        rDatMtrs: array[TMotorOrd] of TMotorData;

        rCurHVPos: THVPosType;
        rCurHVTestType: THVTestType;
        rDatHvs: THVDatas;

        rDatIMS: TImsData;
        rDatMem1Pos, rDatMem2Pos, rDatKeyPos: TMemPosData;

        rBuckleVal,             // ??? ??(????)
        rAncPTVal: Double;        // ??¨¨ PT


        rDatNoise: Double;      // ??? ?©£??? ???? ??(???)

        rSpareVals: array[0..4] of Double;

        rEcuInfoSpec: TEcuInfo;
        rEcuInfo: TEcuInfo;

        rCycleTime: Double;

        rSeatBCs: string[50];
        rIsRework: Boolean;

        rShowNGDebug: Boolean;

        rBCFilePos: Integer;        // BCResult File Pos.

        rREM: array[0..442] of BYTE;

        procedure Clear(IncModel: Boolean = True);

        procedure SetCurHVIdx(HVPos: THVPosType; HVTestType: THVTestType);

        function GetBlowPos: THVPosType;

        function ModelToStr(RO: TResultOrd; IsUnit: Boolean = False): string;

    end;

    // ------------------
    TFaGRAPH_ORD = (faSlide, faSlide_NOISE, faTilt, faTilt_NOISE, faHeight, faHeight_NOISE, faLegSupt, faLegSupt_NOISE, faSwivel, faSwivel_NOISE);

    pFaGraphEnv = ^TFaGraphEnv;

    pColorList = ^TColorList;

    TColorList = array[0..7] of TColor;

    TFaGraphEnv = packed record // size of 128
        rID: Integer;
        rXMax, rXMin, rXStep, rYMax, rYMin, rYStep: Double;
        rSpecLine: TColorList; // spec Line
        rDataLine: TColorList; // Data Line
        // rModel   : Integer ; // ModelID [1, 2]
        rREM: array[0..11] of BYTE;
    end;

    TSpcEnv = packed record // 36 byte
        rSPCUCL, rSPCLCL, rSPCCL: Double;

        rstdXbar: Integer; // ?????...
        rMethod: Integer; // 0: Use spec(internal), 1: User Input(External)
        rstdExAver: array[0..7] of Boolean;
    end;

    TDeliveryPos = packed record
        rPos: BYTE; //0 : Forw, 1: Back, 2: Time : ??????, ?????, ?©£?(???)
        rWay: TMotorWayOrd;

        function GetDir(): TMotorWayOrd;
        function GetTime(): Double;
        function InRange(Val: Double; Margin: Double = 0): Boolean;

        case Integer of
            0:
                (rTime: Double;  // ?©£? ??? ???
                rMax: Double;
                rTemp: Double);
            1:
                (rMin: Double;
                rMax2: Double;
                rTemp2: Double);
            2:
                (rDist: Double;
                rMax3: Double;
                rTemp3: Double);

    end;    // record ????¨ö? end ????? !!!   , rTime, rMin, rDist?? ???? ???? ??? ???

    TMotorDeliveryPos = packed record // sizeof 350
        rTypeBits: DWORD;
        rMotors: array[False..True, 0..3] of TDeliveryPos;
        rMEM2: array[0..2] of TDeliveryPos; // 2013.06.20 ??,?????????? ???????? ??? ????? ?????.
        rSelect: Boolean; // 2013.06.20 False -> MEM1, True -> MEM2
        rREM: array[0..220] of BYTE;
    end;

    TUsrCount = packed record
        rTime: Double;
        rCount: array[0..1, False..True] of Integer; // ??????,??/??
    end;

{==============================================================================}
{   TModels (?? ???? ??????)                                                 }
{==============================================================================}

    // Dir & files
    TUsrDir_ORD = (udHOME, udENV, udGRAPH, udRESULT, udTEMP, udSPC, udRS, udDATA, udGRP_DATA, udGRP);

    TUserChs = (ucHeat, ucVent, ucBuckle, ucAncPT, ucSP05, ucSP06, ucSP07, ucSP08, ucSP09, ucSP10, ucSP11, ucSP12, ucSP13, ucSP14, ucSP15, ucSP16, ucSP17, ucSP18, ucSP19, ucSP20);

    TOffset = packed record
        rVals: array[TUserChs] of Double;

        function GetHVOffset(HVTestType: THVTestType): Double;
    end;

    TOutPos = packed record
        rType: byte;
        rTime: single;
        rDir4Time: TMotorDir;
    public
        function GetDir(): TMotorDir;
        function GetTime(): single;
    end;

    TMotorOffsetItem = packed record
        rCurr, rSpeed, rInitNoise, rRunNoise: Single;

        rREM: array[0..10] of BYTE;
    end;

    TMotorOffset = packed record
        rVals: array[TMotorOrd, TMotorDir] of TMotorOffsetItem;
    end;

    PModels = ^TModels;

    POffset = ^TOffset;

    PMotorOffset = ^TMotorOffset;

    TModels = packed record // sizeof = ??
        rIndex: WORD;

        rTypes: TModelType;
        rPartName: string[63];
        rPartNo: string[63];

        rSpecs: TSpecs;
        rConstraints: array[TMotorOrd] of TMotorConstraints;

        rMtrOffset: array[0..MAX_ST_COUNT - 1] of TMotorOffset; // ???? ?¬ڿ
        rOffset: array[0..MAX_ST_COUNT - 1] of TOffset; // ???? ?¬ڿ


        rOutPos: array[TMotorOrd] of TOutPos;  // ???? ???

        rRearSensorIdx: byte;            // ??? ???? ???? Idx

        rREM: array[0..940] of BYTE;

    end;

    TOutPosInfo = packed record
        mType: Integer;                // ????? : ??????? ?????
        mSensorIdx: Integer;                // ????? ?????? ???? Idx : 0:#13 1:#14 2: ???
        mSpec: array[0..1] of TRange;           // ?????? ?????? ??? SPEC
        mDirs: array[TMotorOrd] of TMotorDir;     // ????? ???? ??? ???

        function IsIn(Dis1, Dis2: Double): Boolean;
    end;

    TMdlExData = packed record
        mID: Integer;
        mTypeBits: DWORD;
        mOutPosInfos: array[TStationID] of TOutPosInfo;

        mSpare: array[0..20] of byte;

        constructor Create(ID: Integer; TypeBits: DWORD);
        function Write(FileHandle: Integer): Boolean;
        function ToKeyStr: string;
    end;


    // --------------------------------
    TTsModeORD = (
    // ?????? General states ??????????????????????????????????????????????????????????????
        tw_NONE, tw_INIT, tw_TEST_MODE,

    // ?????? POP & ?? ?¥忠??????????????????????????????????????????????????????????
        tw_POP_LINK_MODE, tw_POP_RCVD_MODEL, tw_PDT_LOADED,

    // ?????? ?? ???? ?? ??????????????????????????????????????????????????????????????
        tw_START, tw_STOP, tw_END, tw_SAVE, tw_ARRANGE,

    // ?????? ¨¨???? ??? ??? ??? ??????????????????????????????????????????????????????????????
        tw_CON_CHK, tw_SPEC_CHK_START, tw_SPEC_CHK_END, tw_CHK_DISCONNECT,

    // ?????? F/P  ??????????????????????????????????????????????????????????????????
        tw_FP_START, tw_FP_END,

    // ?????? ??? ???? ??????????????????????????????????????????????????????????????????
        tw_INIT_POS_START, tw_INIT_POS_END,

    // ??????  ???? ??????????????????????????????????????????????????????
        tw_CHECK_LOAD_RELEASE, tw_MEAS_START, tw_MEAS_STOP,

    // ?????? ?????  ??????????????????????????????????????????????????????????????????
        tw_BURNISHING_START, tw_BURNISHING_CYCLE, tw_BURNISHING_END,

    // ?????? ??¥忬 ??????  ??????????????????????????????????????????????????????????????
        tw_UNLOADING, tw_CHECK_ALL_TEST_END, tw_DELIVERY_START, tw_DELIVERY_END, tw_DELIVERY_PASS,

    // ?????? ?????????¢®?????? ??????????????????????????????????????????????????????????
        tw_ERROR, tw_EMERGY, tw_ALARM, tw_STATUS, tw_MSG, tw_MSG2,

    // ?????? POP  ????????????????????????????????????????????????????????????????????????
        tw_POP_PASS, tw_POP_START, tw_POP_END,

    // ?????? ???? ?? ??? ???¥쿿? ??????????????????????????????????
        tw_POWER_CHECK, tw_OTHER_PROC_END_CHECK,

    // ?????? ???? ???? ??????????????????????????????????????????????????????????????????
        tw_MTR_TEST_START, tw_MTR_TEST_STOP, tw_LIMIT_START, tw_LIMIT_READED, tw_LIMIT_DONE, tw_MOTOR_INIT,

    // ?????? ??? ??? ??????????????????????????????????????????????????????????????????
        tw_MEMORY_START, tw_MEMORY_END, tw_MEM1_PLAY, tw_MEM1_SAVE, tw_MEM1_ARRANGE, tw_MEM2_PLAY, tw_MEM2_SAVE, tw_MEM2_ARRANGE, tw_KEY_ON, tw_KEY_OFF, tw_KEY_ARRANGE,

    // ?????? HV ???  ????????????????????????????????????????????
        tw_HV_TEST_START, tw_HV_STEP_START, tw_HV_STEP_END, tw_HV_TEST_END, tw_BLOW_START, tw_BLOW_END, tw_FAN_4_NOISE_START, tw_FAN_4_NOISE_END,

    // ?????? ???  ??????????????????????????????????????????????????????
        tw_BUCK_TEST_START, tw_BUCK_TEST_END,

    // ?????? DTC  ??????????????????????????????????????????????????????
        tw_DTC_CLEAR_START, tw_DTC_CLEAR_END,

    // ?????? AnchorPT  ??????????????????????????????????????????????????????
        tw_APT_START, tw_APT_END,

    // ?????? ECU Info Read ??????????????????????????????????????????????????????
        tw_ECU_INFO_START, tw_ECU_INFO_END,

    // ?????? ????, ???? ??????????????????????????????????????????????????????????
        tw_BLUE_LINK, tw_HALL_SENSOR, tw_ABNML_SOUND,

    // ?????? ????? ???? ??????????????????????????????????????????????????????????????????
        tw_BC_READED, tw_MECH_BC_READED, tw_PART_BC_READED,

    // ?????? ¨¨???? ???? ?? ??????  ??????????????????????????????????????????????????
        tw_MID_POS_OK, tw_CON_INFO_LOADED,

    // ?????? ??? ????????????????????????????????????????????????????????????????????????????????
        tw_HIDE_MSG);

const
    umtWarning = mtWarning;
    umtError = mtError;
    umtInformation = mtInformation;
    umtConfirmation = mtConfirmation;
    umtCustom = mtCustom;
    _CO_SYMBOL = 'DAEWON.CO.LTD,.';

    { Graph Env }
    USR_COLOR = $00E0CBC5;
    ENV_FILE = 'Reference.ini';
    DIR_ENV = '\Env';
    DIR_RESULT = '\Result';
    DIR_SPC = '\SPC';
    DIR_TEMP = '\Temp';
    FILE_GRP = 'graph.env';
    FILE_HW = 'hardware.env';
    NG_TAG = '$';
    OK_TAG = '@';

//    NG_TAG = ' ';
//    OK_TAG = '';

    ARY_TAG: array[False..True] of string = (NG_TAG, OK_TAG);
    JUDGE_COLOR: array[False..True] of TColor = (clRed, COLOR_OK);
    JUDGE_COLOR2: array[False..True] of TColor = (clRed, clBlue);
    JUDGE_TXT: array[False..True] of string = ('NG', 'OK');
    OnNOff: array[False..True] of string = ('OFF', 'ON');
    GRP_EXT: array[ord(Low(TFaGRAPH_ORD))..ord(High(TFaGRAPH_ORD))] of string = ('Slide', 'Slide Noise', 'Tilt', 'Tilt Noise', 'Height', 'Height Noise', 'Leg Support', 'Leg Support Noise', 'Swivel', 'Swivel Noise');


    { ????? ???? ???? ???? }
    ARY_DATA_LINE_COUNT: array[TFaGRAPH_ORD] of Integer = (
    4, 4,  // Slide, Slide_NOISE
    4, 4,  // Tilt, Tilt_NOISE
    4, 4,  // Height, Height_NOISE
    4, 4,  // LegSupt, LegSupt_NOISE
    4, 4   // Swivel, Swivel_NOISE
);
    ARY_SPEC_LINE_COUNT: array[TFaGRAPH_ORD] of Integer = (
    4, 4,  // Slide, Slide_NOISE
    4, 4,  // Tilt, Tilt_NOISE
    4, 4,  // Height, Height_NOISE
    4, 4,  // LegSupt, LegSupt_NOISE
    4, 4   // Swivel, Swivel_NOISE
);
    // ???? ???? : 2????, ????? 4

    DataGridORD: array[0..125] of TResultORD = (roIndex, roDate, roTime, roPartName, roCarType, roWayType, roPartNO, roLotNo, roMcNo, roNo,

        //--------------------------
        roRsAbnormalSound,


        //--------------------------
        // Slide
        rospecFwSpeedHiLo,    // ???? ??? ????
        roDataFwSpeed,        // ???? ???
        rospecBwSpeedHiLo,    // ???? ??? ????
        roDataBwSpeed,        // ???? ???
        rospecInitNoiseHi,  // ??? ???? ???? ????
        roDataFwInitNoise,    // ???? ??? ????
        roDataBwInitNoise,    // ???? ??? ????
        rospecRunNoiseHi,   // ??? ???? ????
        roDataFwRunNoise,     // ???? ??? ????
        roDataBwRunNoise,     // ???? ??? ????
        rospecCurrHiLo,    // ???? ????
        roDataFwCurr,     // ???? ????
        roDataBwCurr,     // ???? ????
        roRsLimit,

        //--------------------------
        // Tilt
        rospecFwSpeedHiLo,    // ???? ??? ????
        roDataFwSpeed,        // ???? ???
        rospecBwSpeedHiLo,    // ???? ??? ????
        roDataBwSpeed,        // ???? ???
        rospecInitNoiseHi,  // ??? ???? ???? ????
        roDataFwInitNoise,    // ???? ??? ????
        roDataBwInitNoise,    // ???? ??? ????
        rospecRunNoiseHi,   // ??? ???? ????
        roDataFwRunNoise,     // ???? ??? ????
        roDataBwRunNoise,     // ???? ??? ????
        rospecCurrHiLo,    // ???? ????
        roDataFwCurr,     // ???? ????
        roDataBwCurr,     // ???? ????
        roRsLimit,

        //--------------------------
        // Height
        rospecFwSpeedHiLo,    // ???? ??? ????
        roDataFwSpeed,        // ???? ???
        rospecBwSpeedHiLo,    // ???? ??? ????
        roDataBwSpeed,        // ???? ???
        rospecInitNoiseHi,  // ??? ???? ???? ????
        roDataFwInitNoise,    // ???? ??? ????
        roDataBwInitNoise,    // ???? ??? ????
        rospecRunNoiseHi,   // ??? ???? ????
        roDataFwRunNoise,     // ???? ??? ????
        roDataBwRunNoise,     // ???? ??? ????
        rospecCurrHiLo,    // ???? ????
        roDataFwCurr,     // ???? ????
        roDataBwCurr,     // ???? ????
        roRsLimit,

        //--------------------------
        // LegSupt
        rospecFwSpeedHiLo,    // ???? ??? ????
        roDataFwSpeed,        // ???? ???
        rospecBwSpeedHiLo,    // ???? ??? ????
        roDataBwSpeed,        // ???? ???
        rospecInitNoiseHi,  // ??? ???? ???? ????
        roDataFwInitNoise,    // ???? ??? ????
        roDataBwInitNoise,    // ???? ??? ????
        rospecRunNoiseHi,   // ??? ???? ????
        roDataFwRunNoise,     // ???? ??? ????
        roDataBwRunNoise,     // ???? ??? ????
        rospecCurrHiLo,    // ???? ????
        roDataFwCurr,     // ???? ????
        roDataBwCurr,     // ???? ????
        roRsLimit,

        //--------------------------
        // Swivel
        rospecFwSpeedHiLo,    // ???? ??? ????
        roDataFwSpeed,        // ???? ???
        rospecBwSpeedHiLo,    // ???? ??? ????
        roDataBwSpeed,        // ???? ???
        rospecInitNoiseHi,  // ??? ???? ???? ????
        roDataFwInitNoise,    // ???? ??? ????
        roDataBwInitNoise,    // ???? ??? ????
        rospecRunNoiseHi,   // ??? ???? ????
        roDataFwRunNoise,     // ???? ??? ????
        roDataBwRunNoise,     // ???? ??? ????
        rospecCurrHiLo,    // ???? ????
        roDataFwCurr,     // ???? ????
        roDataBwCurr,     // ???? ????
        roRsLimit,

        //--------------------------
        // IMS
        roRsMem1, roRsMem2, roRsEasyAccess, // ??????
        roRsIMS,

        //--------------------------
        // H/V
        // Drv Htr
        rospecHeatOnHiLo, roDatOnCurr, rospecHeatOffHiLo, roDatOffCurr, roRsLedHi, roRsLedMid, roRsLedLo, roRsLedOff,
        // Drv Vnt
        rospecHeatOnHiLo, roDatOnCurr, rospecHeatOffHiLo, roDatOffCurr, roRsLedHi, roRsLedMid, roRsLedLo, roRsLedOff,
        // Ass Htr
        rospecHeatOnHiLo, roDatOnCurr, rospecHeatOffHiLo, roDatOffCurr, roRsLedHi, roRsLedMid, roRsLedLo, roRsLedOff,
        // Ass Vnt
        rospecHeatOnHiLo, roDatOnCurr, rospecHeatOffHiLo, roDatOffCurr, roRsLedHi, roRsLedMid, roRsLedLo, roRsLedOff,


        // ???
        roSpecBuckleHiLo, roDatBuckle, roRsBuckle,

        // ??¨¨ PT
        rospecAncPT, roDatAncPT, roRsAncPT,

        // ECU Info
        roDataEcuPartNo, roDataEcuSwVer, roDataEcuHwVer);
    PopDataORD: array[0..10] of TResultORD = (roIndex, roDate, roTime, roPartNo, roLotNo, roNo, roNone, roNone, roNone, roNone,
        // ---------------------------------------------------
        // ???? ???
        // ---------------------------------------------------

                // ????
        roRsAbnormalSound);

procedure sysEnvUpdates;

function GetUsrDir(aType: TUsrDir_ORD; aSrc: TDatetime; IsCreate: Boolean = True): string; // result is Home\%s\%s...

function GetResultFileName(ATime: TDatetime; IsCreate: Boolean = True): string; overload;

function GetResultFileName(aTime: TDateTime; Ext: string; IsCreate: Boolean = True): string; overload;

function GetTempFileName(aName: string; IsCreate: Boolean = True): string;

procedure CheckFolder(aDir: string);

function GetOneDayTime(const ATime: TDatetime): TDatetime;

function GetPPM(aOK, aNG: Double): Double;

function GetOkRate(aOK, aNG: Integer): Double;

function GetNgRate(aOK, aNG: Integer): Double;

function IsTxtInList(List: TStrings; const Txt: string): Boolean;

function Load(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: Integer): Boolean;

function Save(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: Integer): Boolean;

function GetErShowTime: Integer;

procedure SetErShowTime(ATime: Integer);
// Graph BackGround Image File name

function GetFloatToStr(aValue: Double): string; overload;

function GetFloatToStr(aValue: Double; aDigit: Integer): string; overload;

function GetDipValue(aValue: Double): Double;
// Count

procedure SetResultReset;
// procedure SetDecCount(AResult: Boolean) ;

procedure SetResultCount(Index: Integer; AResult: Boolean);

function GetResultCount(Index: Integer; AResult: Boolean): Integer; overload;
// Graph

function IsCpkGraphIndex(AIndex: Integer): Boolean;

function GetGrpEnv(aGrp: Integer): TFaGraphEnv;

function SetGrpEnv(aBuf: TFaGraphEnv): Boolean;

function GetGraphLineName(aSection: string; aSubIndex: Integer; IsData: Boolean): string;

procedure SetGraphLineName(aSection, aName: string; aSubIndex: Integer; IsData: Boolean);
// Newer

procedure UsrGraphInitial(aGraphEx: TFaGraphEx; gtValue: TGraphType; IsClear: Boolean);

procedure SaveGraphDatas(const ATime: Double; aGraph: TFaGraphEx);

procedure LoadGraphDatas(const ATime: Double; aGraph: TFaGraphEx);

procedure DrawUsrGraphDatas(ATitle: string; ACanvas: TCanvas; ADatas: TPoint; AstdPos: TRect; X, Y: string; AOrd: Integer);

procedure SetErrorTxt(ACaption, AError, ATodo: string; DlgType: TMsgDlgType = mtError);

function GetStationName(StationID: TStationID): string;

function GetDevComName(ADevComID: TDevComORD): string;

function GetCompTime(sTime, eTime, ATime: Double): Boolean;

function GetCanDevName(aDevCanID: TDevCanORD): string;

procedure GetStNamesNCarNames(StNames, CarNames: TStrings);

function GetSeconds(ATime: TDatetime): Double;

function GetDateToSec(ATime: TDatetime): Double;

function GetTimeToSec(ATime: TDatetime): Double;

procedure DrawTLeft(Canvas: TCanvas; X, Y, w, h: Integer);

procedure DrawTRight(Canvas: TCanvas; X, Y, w, h: Integer);

function SetGraphFileDelete(stdTime: TDatetime): Boolean;

function GetMinutes(ATime: TDatetime): Double;

function GetDateToMin(ATime: TDatetime): Double;

function GetTimeToMin(ATime: TDatetime): Double;

procedure SaveGridColWidths(AGrid: TStringGrid; aName: string);

procedure LoadGridColwidths(AGrid: TStringGrid; aName: string);

function ToHexLog(const LogMsg; len: Integer): string;

function LoadDeviceNumber(DevName: string): Integer;

procedure SaveDeviceNumber(DevName: string; Value: Integer);

// procedure SaveDeliveryPos;

procedure SaveUsrDeliveryPos(const aBuf: TMotorDeliveryPos);

function LoadUsrDeliveryPos(const TypeBits: DWORD): TMotorDeliveryPos;

function JudgeToStr(Dec: TResultJudge): string;

function BoolToJudge(Val: Boolean): TResultJudge;

function MotorOrd2TsOrd(Mtr: TMotorOrd): TTsOrD;

function TsOrd2MotorOrd(Ts: TTsOrd): TMotorOrd;

function IsBwdRO(RO: TResultOrd): Boolean;


// ------------------------------------------------------------

var
    gMsgData: TMsgData;
    gUsrMsg: HWND = 0;

    // ???? ??¥忠????-> 1= ??????, 2=???
    // ???? ????? 0 ??? ???????? 2???, ??? 2???.
    gTsFuncProc: array[0..1] of BYTE;
    gDioReferwnd: HWND = 0;
    gCycleTime: array[0..1] of Double;
    gCanDebugMode: Boolean = False;
    gPwrDebugMode: Boolean = False;
    gsysRunMode: Boolean = False;

implementation

uses
    Math, StdCtrls, RS232, Log, UserComLibEx, ErrorForm, UserTool, DateUtils,
    ModelUnit, KiiFaGraphDB, DataUnitHelper, SysEnv, SeatTypeUI, LangTran;

const
    INT_GRP_ENV: TFaGraphEnv = (
        rXMax: 100;
        rXMin: 0;
        rXStep: 20;
        rYMax: 5;
        rYMin: 0;
        rYStep: 1;
        rSpecLine: ($00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6, $00FFA6A6);
        // spec Line
        rDataLine: (clRed, clBlue, clMaroon, clOlive, clNavy, clPurple, clTeal, clSilver); // Data Line
    );
    INT_SPC_ENV: TSpcEnv = (
        rSPCUCL: 4;
        rSPCLCL: 0;
        rSPCCL: 2;
        rstdXbar: 2; // ?????...
        rMethod: 0;
    );

var
    lpUsrCount: TUsrCount;
    lpUsrstdDate: TDatetime = 0;

    // ------------------------------------------------------------------------------
    //
    // ------------------------------------------------------------------------------
procedure UsrLogApped(Value: string);
var
    fd: Integer;
    yy, mm, dd: WORD;
    sTm: string;
begin
    DecodeDate(Now(), yy, mm, dd);
    sTm := GetUsrDir(udHOME, Now()) + '\LOG\' + Format('%.4d%.2d%.2d.LOG', [yy, mm, dd]);
    if FileExists(sTm) then
        fd := FileOpen(sTm, fmOpenWrite)
    else
        fd := FileCreate(sTm);

    sTm := Value + #13 + #10;
    FileSeek(fd, 0, FILE_END);
    FileWrite(fd, PChar(sTm)^, Length(sTm) * sizeof(Char));
    FileClose(fd);
end;

function GetPPM(aOK, aNG: Double): Double;
var
    dTm: Double;
begin
    // ????? : (aNG/aOK)*100
    // PPM    : ????? * 100??
    // 2005.06.03
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aNG / dTm) * 1000000;
end;

function GetOkRate(aOK, aNG: Integer): Double;
var
    dTm: Double;
begin
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aOK / dTm) * 100.0;
end;

function GetNgRate(aOK, aNG: Integer): Double;
var
    dTm: Double;
begin
    dTm := aOK + aNG;
    if dTm = 0 then
        Result := 0.0
    else
        Result := (aNG / dTm) * 100.0;
end;

procedure LoadLastCount;
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), ENV_FILE]);
    Ini := TIniFile.Create(sTm);
    try
        with Ini do
        begin
            lpUsrCount.rCount[0, False] := Ini.ReadInteger('COUNT', '#1 OK', 0);
            lpUsrCount.rCount[0, True] := Ini.ReadInteger('COUNT', '#1 NG', 0);
            lpUsrCount.rCount[1, False] := Ini.ReadInteger('COUNT', '#2 OK', 0);
            lpUsrCount.rCount[1, True] := Ini.ReadInteger('COUNT', '#2 NG', 0);
            lpUsrCount.rTime := Ini.ReadFloat('COUNT', 'TIME', GetOneDayTime(Now()));

        end;
    finally
        Ini.Free;
    end;
end;

procedure SaveCount;
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), ENV_FILE]);
    Ini := TIniFile.Create(sTm);
    try
        with Ini do
        begin
            Ini.WriteInteger('COUNT', '#1 OK', lpUsrCount.rCount[0, False]);
            Ini.WriteInteger('COUNT', '#1 NG', lpUsrCount.rCount[0, True]);
            Ini.WriteInteger('COUNT', '#2 OK', lpUsrCount.rCount[1, False]);
            Ini.WriteInteger('COUNT', '#2 NG', lpUsrCount.rCount[1, True]);
            Ini.WriteFloat('COUNT', 'TIME', lpUsrCount.rTime);

        end;
    finally
        Ini.Free;
    end;
end;

// MainTimer, DataBox save ????.
procedure sysEnvUpdates;
begin
    if Trunc(gSysEnv.rOP.rLoadTime) <> Trunc(Now()) then
    begin
        gSysEnv.rOP.rLoadTime := Now;
        gSysEnv.rOP.rLotNo := 0;
        gSysEnv.Save(eiOP);
    end;

    with lpUsrCount do
    begin
        if Trunc(rTime) <> Trunc(GetOneDayTime(Now())) then
        begin
            rTime := GetOneDayTime(Now());
            rCount[0, False] := 0;
            rCount[0, True] := 0;
            rCount[1, False] := 0;
            rCount[1, True] := 0;

            SaveCount();

            SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
            SendToForm(gUsrMsg, SYS_CPK, 0);
        end;
    end;
end;


function GetUsrDir(aType: TUsrDir_ORD; aSrc: TDatetime; IsCreate: Boolean): string;
begin
    case aType of
        udHOME:
            Result := GetHomeDirectory;
        udENV:
            Result := GetUsrDir(udHOME, aSrc) + DIR_ENV;
        udGRAPH:
            Result := GetUsrDir(udRESULT, aSrc) + Format('\%s', [FormatDateTime('yyyymmdd', aSrc)]);
        udRESULT:
            begin
                Result := GetUsrDir(udRS, aSrc, IsCreate);
                Result := Format('%s\%s', [Result, FormatDateTime('yyyymm', aSrc)]);
            end;
        udTEMP:
            Result := GetUsrDir(udHOME, aSrc) + DIR_TEMP;
        udSPC:
            Result := GetUsrDir(udHOME, aSrc) + DIR_SPC;
        udRS:
            Result := GetUsrDir(udDATA, aSrc) + DIR_RESULT;
        udDATA:
            begin
                if gSysEnv.rOP.rResultDir <> '' then
                    Result := string(gSysEnv.rOP.rResultDir)
                else
                    Result := GetUsrDir(udHOME, aSrc);
            end;
        udGRP_DATA:
            begin
                if gSysEnv.rOP.rGraphDir <> '' then
                    Result := string(gSysEnv.rOP.rGraphDir)
                else
                    Result := GetUsrDir(udDATA, aSrc);
            end;
        udGRP:
            Result := GetUsrDir(udGRP_DATA, aSrc) + DIR_RESULT;
    end;

    if IsCreate and not DirectoryExists(Result) then
        ForceDirectories(Result);
end;

function GetTempFileName(aName: string; IsCreate: Boolean): string;
begin
    Result := Format('%s\%s', [GetUsrDir(udTEMP, Now(), IsCreate), aName]);
end;

function GetResultFileName(ATime: TDatetime; IsCreate: Boolean = True): string;
begin
    Result := Format('%s\%s.dat', [GetUsrDir(udRESULT, ATime, IsCreate), FormatDateTime('yyyymmdd', ATime)]);
end;

function GetResultFileName(aTime: TDateTime; Ext: string; IsCreate: Boolean): string;
begin
    Result := Format('%s\%s.%s', [GetUsrDir(udRESULT, aTime, IsCreate), FormatDateTime('yyyymmdd', aTime), Ext]);
end;

procedure CheckFolder(aDir: string);
var
    i: Integer;
    sTm: string;
begin
    sTm := '';
    for i := 1 to Length(aDir) do
    begin
        if (Length(sTm) > 0) and (aDir[i] = '\') and (aDir[i - 1] <> ':') then
            if not DirectoryExists(sTm) then
                ForceDirectories(sTm);

        sTm := sTm + aDir[i];
    end;
end;

function IsCpkGraphIndex(AIndex: Integer): Boolean;
begin
    Result := False;
    //Result := AIndex In [ord(faCpk1) .. ord(faCpk2)];
end;

function InitGrpEnv(Buf: TFaGraphEnv): TFaGraphEnv;
var
    i: Integer;
begin
    Move(Buf, Result, sizeof(TFaGraphEnv));
    with Result do
    begin
        rXMax := 100;
        rXMin := 0;
        rXStep := 10.0;
        rYMax := 100.0;
        rYMin := 0.0;
        rYStep := 10.0;

        for i := 0 to 7 do
        begin
            rSpecLine[i] := INT_GRP_ENV.rSpecLine[i];
            rDataLine[i] := INT_GRP_ENV.rDataLine[i];
        end;
    end;
end;

function LoadGrp(FileHandle, ID: Integer; var Buf: TFaGraphEnv): Boolean;
begin
    Result := False;
    FileSeek(FileHandle, 0, 0);
    while FileRead(FileHandle, Buf, sizeof(TFaGraphEnv)) = sizeof(TFaGraphEnv) do
    begin
        if Buf.rID = ID then
        begin
            Result := True;
            Break;
        end;
    end;
end;

function GetGrpEnv(aGrp: Integer): TFaGraphEnv;
label
    _INIT_GRP;
var
    sTm: string;
    fh, iTm: Integer;
begin
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), FILE_GRP]);

    fh := 0;
    if FileExists(sTm) then
        fh := FileOpen(sTm, fmOpenRead);
    if fh <= 0 then
        goto _INIT_GRP;

    iTm := FileSeek(fh, 0, 2);
    if (iTm > 0) and ((iTm mod sizeof(TFaGraphEnv)) <> 0) then
    begin
        FileClose(fh);
        RenameFile(sTm, ChangeFileExt(sTm, '.' + FormatDateTime('yymmdd', Now)));
        gLog.ToFiles('GraphEnv File ?????? ?????????.', []);
        goto _INIT_GRP;
    end;

    if not LoadGrp(fh, aGrp, Result) then
    begin
        FileClose(fh);
        goto _INIT_GRP;
    end;
    FileClose(fh);
    Exit;

_INIT_GRP:
    Result.rID := aGrp;
    Result := InitGrpEnv(Result);
end;

function SetGrpEnv(aBuf: TFaGraphEnv): Boolean;
var
    sTm: string;
    fh, iTm: Integer;
    Buf: TFaGraphEnv;
begin
    Result := False;
    sTm := Format('%s\%s', [GetUsrDir(udENV, Now()), FILE_GRP]);

    if FileExists(sTm) then
        fh := FileOpen(sTm, fmOpenReadWrite)
    else
        fh := FileCreate(sTm);
    if fh <= 0 then
        Exit;

    iTm := FileSeek(fh, 0, 2);
    if (iTm > 0) and ((iTm mod sizeof(TFaGraphEnv)) <> 0) then
    begin
        FileClose(fh);
        RenameFile(sTm, ChangeFileExt(sTm, '.' + FormatDateTime('yymmdd', Now)));
        gLog.ToFiles('GraphEnv File ?????? ?????????.', []);
        fh := FileCreate(sTm);
    end;

    if not LoadGrp(fh, aBuf.rID, Buf) then
        FileSeek(fh, 0, 2)
    else
        FileSeek(fh, -sizeof(TFaGraphEnv), 1);

    Result := FileWrite(fh, aBuf, sizeof(TFaGraphEnv)) = sizeof(TFaGraphEnv);
    FileClose(fh);
end;

function GetOneDayTime(const ATime: TDatetime): TDatetime;
begin
    Result := ATime;
    with gSysEnv do
        if Frac(ATime) < Frac(rOP.rWorkTime) then
            Result := Result - 1;
end;


function IsTxtInList(List: TStrings; const Txt: string): Boolean;
var
    i: Integer;
begin
    Result := False;
    for i := 0 to List.Count - 1 do
    begin
        if List.Strings[i] = '' then
            Continue;
        if Pos(List.Strings[i], Txt) > 0 then
        begin
            Result := True;
            Break;
        end;
    end;
end;

function Load(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: Integer): Boolean;
var
    fsLoad: TFileStream;
begin
    Result := False;

    if not FileExists(Filename) then
        Exit;

    fsLoad := TFileStream.Create(Filename, fmOpenRead);
    if fsLoad <> nil then
    begin
        try
            aGraphEx.BeginUpdate();
            aGraphEx.Load(fsLoad, aShareCount);
            aGraphEx.EndUpdate();
        finally
            fsLoad.Free;
            Result := True;
        end;
    end;
end;

function Save(const Filename: string; aGraphEx: TFaGraphEx; aShareCount: Integer): Boolean;
var
    fsSave: TFileStream;
begin
    Result := False;
    if FileExists(Filename) then
        DeleteFile(Filename);

    fsSave := TFileStream.Create(Filename, fmCreate);
    if fsSave <> nil then
    begin
        try
            aGraphEx.Save(fsSave, aShareCount);
        finally
            fsSave.Free;
            Result := True;
        end;
    end;
end;

function GetErShowTime: Integer;
var
    IniFile: TIniFile;
begin
    IniFile := TIniFile.Create(GetIniFiles);
    try
        Result := IniFile.ReadInteger('_ERROR', 'CLOSE_TIME', 360);
    finally
        IniFile.Free;
    end;
end;

procedure SetErShowTime(ATime: Integer);
var
    IniFile: TIniFile;
begin
    IniFile := TIniFile.Create(GetIniFiles);
    try
        IniFile.WriteInteger('_ERROR', 'CLOSE_TIME', ATime);
    finally
        IniFile.Free;
    end;
end;

function GetStrToFileName(aTxt: string): string;
var
    i: Integer;
begin
    Result := '';
    for i := 1 to Length(aTxt) do
    begin
        if aTxt[i] in ['/', '\', ';', '*', '?', '<', '>', '|'] then
            Result := Result + '-'
        else
            Result := Result + aTxt[i];
    end;
end;

function GetFloatToStr(aValue: Double): string;
begin
    Result := GetFloatToStr(aValue, gSysEnv.rOP.rWidth);
end;


function GetFloatToStr(aValue: Double; aDigit: Integer): string;
var
    i, iTm: Integer;
begin
    Result := FloatToStr(aValue);
    if aDigit <= 0 then
        Exit;

    iTm := Pos('.', Result);
    if iTm > 0 then
    begin
        if (Length(Result) - iTm) > aDigit then
        begin
            Result := Copy(Result, 1, iTm + aDigit);
            Exit;
        end
        else
        begin
            iTm := aDigit - (Length(Result) - iTm);
        end;
    end
    else
    begin
        Result := Result + '.';
        iTm := aDigit;
    end;

    for i := 0 to iTm - 1 do
        Result := Result + '0';
end;

function GetFloatToUserData(aValue: Double): Double;
var
    stdUnit: Double;
begin
    stdUnit := Power(10.0, gSysEnv.rOP.rWidth);
    Result := Trunc(stdUnit * aValue) / stdUnit;
end;


function GetDipValue(aValue: Double): Double;
begin
    Result := Round(aValue * Power(10.0, gSysEnv.rOP.rWidth)) / Power(10.0, gSysEnv.rOP.rWidth);
end;

procedure SetResultReset;
begin
    with lpUsrCount do
    begin
        rCount[0, True] := 0;
        rCount[0, False] := 0;
        rCount[1, True] := 0;
        rCount[1, False] := 0;
    end;
    SaveCount();
    SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
end;

procedure SetResultCount(Index: Integer; AResult: Boolean);
begin
    with lpUsrCount do
    begin
        Inc(rCount[Index, AResult]);
    end;
    SaveCount();
    SendToForm(gUsrMsg, SYS_COUNT_UPDATES, 0);
end;

function GetResultCount(Index: Integer; AResult: Boolean): Integer;
begin
    with lpUsrCount do
        Result := rCount[Index, AResult];
end;

const
    KEY_HEAD: array[False..True] of string = ('_SPEC', '_DATA');

function GetGraphLineName(aSection: string; aSubIndex: Integer; IsData: Boolean): string;
var
    Ini: TIniFile;
    sTm, Key: string;
begin
    sTm := Format('%s\GraphLine.env', [GetUsrDir(udENV, Now(), True)]);
    Ini := TIniFile.Create(sTm);
    Key := Format('%s%d', [KEY_HEAD[IsData], aSubIndex]);
    try
        Result := Ini.ReadString(aSection, Key, Copy(Key, 2, Length(Key) - 1));
    finally
        Ini.Free;
    end;
end;

procedure SetGraphLineName(aSection, aName: string; aSubIndex: Integer; IsData: Boolean);
var
    Ini: TIniFile;
    sTm, Key: string;
begin
    sTm := Format('%s\GraphLine.env', [GetUsrDir(udENV, Now(), True)]);
    Ini := TIniFile.Create(sTm);
    Key := Format('%s%d', [KEY_HEAD[IsData], aSubIndex]);
    try
        Ini.WriteString(aSection, Key, aName);
    finally
        Ini.Free;
    end;
end;

procedure UsrGraphInitial(aGraphEx: TFaGraphEx; gtValue: TGraphType; IsClear: Boolean);

    function GetCommaPos(aValue: Double; AUnit: Integer): WORD;
    var
        i: Integer;
        sTm: string;
    begin
        Result := 0;
        if Frac(aValue) = 0 then
            Exit;

        sTm := Format('%0.*f', [AUnit, aValue]);
        sTm := Copy(sTm, Pos('.', sTm) + 1, Length(sTm) - Pos('.', sTm));

        for i := Length(sTm) downto 1 do
        begin
            if sTm[i] <> '0' then
            begin
                Result := i;
                Break;
            end;
        end;
    end;

var
    i: Integer;
    grpEnv: TFaGraphEnv;
    IsNoiseGraph: boolean;
begin
    try
        with aGraphEx do
        begin
            grpEnv := GetGrpEnv(Tag);

            // NOISE ????????? ??? (??? ?¥忿?)
            IsNoiseGraph := Odd(Tag);

            BeginUpdate();

            GraphType := gtValue;
            Zoom := False;
            // ZoomSerie := 0 ;

            if GraphType = gtNormal then
                GridDraw := [ggHori]//[ggVert, ggHori]
            else
                GridDraw := [ggHori];

            if IsClear then
                Empty();
            // GraphORD, ALine, AIndex
            with Axis do
            begin
                // Items[0].Scale   := asNormal ;
                Items[0].Min := grpEnv.rXMin;
                Items[0].Max := grpEnv.rXMax;
                Items[0].Step := grpEnv.rXStep;
                Items[0].Decimal := GetCommaPos(grpEnv.rXStep, 3);

                // Items[1].Scale   := asNormal ;
                Items[1].Min := grpEnv.rYMin;
                Items[1].Max := grpEnv.rYMax;
                Items[1].Step := grpEnv.rYStep;
                Items[1].Decimal := GetCommaPos(grpEnv.rYStep, 3);

                if (Count > 2) then
                begin
                    with GetGrpEnv(Tag + 1) do
                    begin
                        Items[2].Min := rYMin;
                        Items[2].Max := rYMax;
                        Items[2].Step := rYStep;
                        Items[2].Decimal := GetCommaPos(rYStep, 3);
                    end;
                end;
            end;

            for i := 0 to Series.Count - 1 do
            begin
                Series.Items[i].Visible := True;
                Series.Items[i].LineColor := grpEnv.rDataLine[i mod 8];
                Series.Items[i].PointColor := Series.Items[i].LineColor;
            end;
            EndUpdate();
        end;
    except
        gLog.ToFiles('EXCEPTION: UsrGraphInitial', []);
    end;
end;

procedure SaveGraphDatas(const ATime: Double; aGraph: TFaGraphEx);
begin
    if aGraph.FSdShare.GetMaxIndex(0) <= 0 then
        Exit;
    gKiiDB.Add(ATime, aGraph, aGraph.Series.Count * 2);
end;

procedure LoadGraphDatas(const ATime: Double; aGraph: TFaGraphEx);
var
    KiiDB: TKiiGraphDB;
begin
    KiiDB := TKiiGraphDB.Create(stHour, GetUsrDir(udRS, Now(), False));
    try
        KiiDB.Load(ATime, aGraph, aGraph.Series.Count * 2);
    finally
        FreeAndNil(KiiDB);
    end;
end;

procedure DrawUsrGraphDatas(ATitle: string; ACanvas: TCanvas; ADatas: TPoint; AstdPos: TRect; X, Y: string; AOrd: Integer);
var
    Tmp: TArrowMark;
    fs: Integer;
    sTm: string;
begin
    with ACanvas do
    begin
        SetTextAlign(Handle, TA_CENTER or TA_TOP);
        fs := Font.Size;
        Font.Size := Trunc(fs * 0.9);
        sTm := Format('%s' + #13 + '%s %s', [ATitle, X, Y]);

        case AOrd of
            0:
                Tmp := amTopLeft;
        else
            Tmp := amBottomRight;
        end;

        DrawArrowMark(ACanvas, Tmp, ADatas.X, ADatas.Y, sTm, clNavy, clBlack, True, []);

        Font.Size := fs;
    end;
end;

procedure SetErrorTxt(ACaption, AError, ATodo: string; DlgType: TMsgDlgType);
begin

    if not Assigned(frmError) then
        Exit;

    gMsgData.mCaption := ACaption;
    gMsgData.mMsg1 := AError + #13 + ATodo;
    gMsgData.mTime := GetErShowTime;
    gMsgData.mDlgType := DlgType;

    SendToForm(gUsrMsg, SYS_MSG_ERR, 0);
    {
    try
        frmError.SetFrm(ACaption, AError + #13 + ATodo, GetErShowTime, True, DlgType);
    except
    end;
    }
end;

function GetDevComName(ADevComID: TDevComORD): string;
begin
    case ADevComID of
        dcPS_01:
            Result := 'Pwr.Sply1';

    else
        Result := '';
    end;
end;

function GetCanDevName(aDevCanID: TDevCanORD): string;
begin
    case aDevCanID of
        dcCAN_01:
            Result := 'CAN#1';
    else
        Result := 'CAN#2';
    end;
end;

function GetCompTime(sTime, eTime, ATime: Double): Boolean;
begin
    sTime := Frac(sTime);
    eTime := Frac(eTime);
    ATime := Frac(ATime);

    if sTime < eTime then
        Result := (sTime <= ATime) and (ATime <= eTime)
    else
        Result := not ((eTime <= ATime) and (ATime <= sTime));
end;

function GetTimeToSec(ATime: TDatetime): Double;
var
    hh, nn, ss, zz: WORD;
begin
    Result := ATime;

    DecodeTime(Result, hh, nn, ss, zz);
    Result := hh * 3600;
    Result := Result + (nn * 60);
    Result := Result + ss;
    Result := Result + (Round(zz / 100) / 10);
end;

function GetDateToSec(ATime: TDatetime): Double;
begin
    Result := ATime;
    Result := Trunc(Result) * SecsPerDay;
end;

function GetSeconds(ATime: TDatetime): Double;
begin
    Result := ATime;
    if Result <= 0 then
    begin
        Result := 0;
        Exit;
    end
    else if (Result > 0) and (Result < 1) then
    begin
        Result := GetTimeToSec(ATime);
    end
    else
    begin
        Result := GetTimeToSec(ATime) + GetDateToSec(ATime);
    end;
end;

procedure DrawTLeft(Canvas: TCanvas; X, Y, w, h: Integer);
begin
    with Canvas do
    begin
        w := (w shr 1) shl 1;
        h := (h shr 1) shl 1;

        Polygon([Point(X - w, Y), Point(X + w, Y - h), Point(X + w, Y + h)]);
    end;
end;

procedure DrawTRight(Canvas: TCanvas; X, Y, w, h: Integer);
begin
    with Canvas do
    begin
        w := (w shr 1) shl 1;
        h := (h shr 1) shl 1;

        Polygon([Point(X + w, Y), Point(X - w, Y - h), Point(X - w, Y + h)]);
    end;
end;

function GetOldestFolder(Astd, ADest: string): string;
var
    sTm: string;
    done: Integer;
    srFile: TSearchRec;
begin
    Result := Astd;
    done := Sysutils.FindFirst(ADest + '\*.*', faDirectory, srFile);
    try
        while done = 0 do
        begin
            if (srFile.Name[1] <> '.') and ((srFile.Attr and faDirectory) = faDirectory) then
            begin
                sTm := ADest + '\' + srFile.Name;
                if Length(Astd) <> Length(sTm) then
                begin
                    sTm := GetOldestFolder(Astd, sTm);
                end;

                if Result > sTm then
                begin
                    Result := sTm;
                end;
            end;
            done := Sysutils.FindNext(srFile);
        end;
    finally
        Sysutils.FindClose(srFile);
    end;
end;

function SetGraphFileDelete(stdTime: TDatetime): Boolean;
var
    sTm, grpFile, Dest: string;
    KiiDB: TKiiGraphDB;
begin
    Result := False;
    sTm := GetUsrDir(udGRP, stdTime, False);
    if not DirectoryExists(sTm) then
        Exit;

    try
        KiiDB := TKiiGraphDB.Create(stHour, GetUsrDir(udGRP, Now, True));
        grpFile := KiiDB.GetGraphFileName(stdTime, False);
        Dest := GetOldestFolder(ExtractFileDir(grpFile), sTm);
        if Dest = ExtractFileDir(grpFile) then
            Exit;
        Zap(Dest);
        gLog.ToFiles('start Del old graph file: %s', [Dest]);
        RemoveDir(Dest);
        gLog.ToFiles('end Del old graph file: %s', [Dest]);
    finally
        FreeAndNil(KiiDB);
    end;
    Result := True;
end;

function GetTimeToMin(ATime: TDatetime): Double;
var
    hh, nn, ss, zz: WORD;
begin
    Result := ATime;

    DecodeTime(Result, hh, nn, ss, zz);
    Result := hh * 60;
    Result := Result + nn;
    if ss > 0 then
    begin
        nn := Length(IntToStr(ss));
        Result := Result + ss / Power(10, nn);
    end
    else
        Result := Result;
    ;
end;

function GetDateToMin(ATime: TDatetime): Double;
begin
    Result := ATime;
    Result := Trunc(Result) * MinsPerDay;
end;

function GetMinutes(ATime: TDatetime): Double;
begin
    Result := ATime;
    if Result <= 0 then
    begin
        Result := 0;
        Exit;
    end
    else if (Result > 0) and (Result < 1) then
    begin
        Result := GetTimeToMin(ATime);
    end
    else
    begin
        Result := GetTimeToMin(ATime) + GetDateToMin(ATime);
    end;
end;

procedure SaveGridColWidths(AGrid: TStringGrid; aName: string);
var
    i: Integer;
    sTm: string;
begin
    sTm := Format('%s\GridWidths.env', [GetUsrDir(udENV, Now, False)]);
    with TIniFile.Create(sTm) do
    begin
        try
            for i := 0 to AGrid.ColCount - 1 do
            begin
                WriteInteger(aName, 'COL_' + IntToStr(i), AGrid.ColWidths[i]);
            end;
        finally
            Free;
        end;
    end;
end;

procedure LoadGridColwidths(AGrid: TStringGrid; aName: string);
var
    i: Integer;
    sTm: string;
begin
    sTm := Format('%s\GridWidths.env', [GetUsrDir(udENV, Now, False)]);
    if not FileExists(sTm) then
        Exit;
    with TIniFile.Create(sTm) do
    begin
        try
            for i := 0 to AGrid.ColCount - 1 do
            begin
                AGrid.ColWidths[i] := ReadInteger(aName, 'COL_' + IntToStr(i), 100);
            end;
        finally
            Free;
        end;
    end;
end;

function ToHexLog(const LogMsg; len: Integer): string;
var
    i: Integer;
begin
    Result := '';
    for i := 0 to len - 1 do
        Result := Result + IntToHex(TByteArray(LogMsg)[i], 2) + ' ';
end;

function GetStationName(StationID: TStationID): string;
begin
    {
    if gSysEnv.rStGroupNo <= 1 then
        Result := Format('#%d', [gSysEnv.rStNo + Ord(StationID)])
    else
        Result := Format('#%d-%d', [gSysEnv.rStNo + Ord(StationID), gSysEnv.rStGroupNo - 1]);
    }
    Result := Format('%dth', [gSysEnv.rOP.rStNo + Ord(StationID)]);
    //Result := '';
end;

procedure GetStNamesNCarNames(StNames, CarNames: TStrings);
var
    i: Integer;
    j: TCAR_TYPE;
begin
    if StNames <> nil then
    begin
        StNames.Clear;
        for i := 0 to MAX_ST_COUNT - 1 do
        begin
            StNames.Add(GetStationName(TStationID(i)));
        end;
    end;

    if CarNames <> nil then
    begin
        CarNames.Clear;
        for j := Low(TCAR_TYPE) to High(TCAR_TYPE) do
        begin
            CarNames.Add(TCAR_TYPE_STR[Ord(j)]);
        end;

    end;
end;

procedure SaveUsrDeliveryPos(const aBuf: TMotorDeliveryPos);
var
    sTm: string;
    fh, iDx: Integer;
    Buf: TMotorDeliveryPos;
begin
    iDx := 0;
    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if FileExists(sTm) then
    begin
        fh := FileOpen(sTm, fmOpenRead);
        try
            while FileRead(fh, Buf, sizeof(TMotorDeliveryPos)) = sizeof(TMotorDeliveryPos) do
            begin
                if Buf.rTypeBits = aBuf.rTypeBits then
                begin
                    iDx := FileSeek(fh, 0, 1) div sizeof(TMotorDeliveryPos);
                    Break;
                end;
            end;
        finally
            FileClose(fh);
        end;
    end;

    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if not FileExists(sTm) then
        fh := FileCreate(sTm)
    else
        fh := FileOpen(sTm, fmOpenWrite);
    try
        if iDx > 0 then
            FileSeek(fh, (iDx - 1) * sizeof(TMotorDeliveryPos), 0)
        else
            FileSeek(fh, 0, 2);
        FileWrite(fh, aBuf, sizeof(TMotorDeliveryPos));
    finally
        FileClose(fh);
    end;
end;

function LoadUsrDeliveryPos(const TypeBits: DWORD): TMotorDeliveryPos;
var
    sTm: string;
    fh: Integer;
begin
    FillChar(Result, sizeof(TMotorDeliveryPos), 0);
    sTm := Format('%s\MotorDeliveryPos.dat', [GetUsrDir(udENV, Now())]);
    if FileExists(sTm) then
    begin
        fh := FileOpen(sTm, fmOpenRead);
        try
            while FileRead(fh, Result, sizeof(TMotorDeliveryPos)) = sizeof(TMotorDeliveryPos) do
            begin
                if Result.rTypeBits = TypeBits then
                    Break
                else
                    Result.rTypeBits := 0;
            end;
        finally
            FileClose(fh);
        end;
    end;

    if Result.rTypeBits = 0 then
    begin
        Result.rTypeBits := TypeBits;
        Result.rMotors[False, 0].rPos := 0;
        Result.rMotors[False, 0].rTime := 2.0;
        Result.rMotors[False, 1].rPos := 0;
        Result.rMotors[False, 1].rTime := 2.0;
        Result.rMotors[False, 2].rPos := 0;
        Result.rMotors[False, 2].rTime := 2.0;

        Result.rMotors[True, 0].rPos := 0;
        Result.rMotors[True, 0].rTime := 2.0;
        Result.rMotors[True, 1].rPos := 0;
        Result.rMotors[True, 1].rTime := 2.0;
        Result.rMotors[True, 2].rPos := 0;
        Result.rMotors[True, 2].rTime := 2.0;
    end;
end;

function LoadDeviceNumber(DevName: string): Integer;
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\DeviceInfo.ini', [GetUsrDir(udENV, Now())]);
    Ini := TIniFile.Create(sTm);
    try
        Result := Ini.ReadInteger(DevName, 'DEV NUMBER', 0);
        if not Ini.SectionExists(DevName) then
        begin
            Ini.WriteInteger(DevName, 'DEV NUMBER', Result);
        end;
    finally
        Ini.Free;
    end;
end;

procedure SaveDeviceNumber(DevName: string; Value: Integer);
var
    sTm: string;
    Ini: TIniFile;
begin
    sTm := Format('%s\DeviceInfo.ini', [GetUsrDir(udENV, Now())]);
    Ini := TIniFile.Create(sTm);
    try
        Ini.WriteInteger(DevName, 'DEV NUMBER', Value);
    finally
        Ini.Free;
    end;
end;

function JudgeToStr(Dec: TResultJudge): string;
begin
    case Dec of
        rjNone:
            Result := 'None';
        rjOK:
            Result := JUDGE_TXT[True];
        rjNG:
            Result := JUDGE_TXT[False];
    end;

end;

function BoolToJudge(Val: Boolean): TResultJudge;
begin
    if Val then
        Exit(rjOK);

    Exit(rjNG);
end;

function MotorOrd2TsOrd(Mtr: TMotorOrd): TTsORD;
begin
    case Mtr of
        tmSlide:
            Result := tsSlide;
        tmTilt:
            Result := tsTilt;
        tmHeight:
            Result := tsHeight;
        tmLegSupt:
            Result := tsLegSupt;
        tmSwivel:
            Result := tsSwivel;
    end;
end;

function TsOrd2MotorOrd(Ts: TTsOrd): TMotorOrd;
begin
    case Ts of
        tsSlide:
            Result := tmSlide;
        tsTilt:
            Result := tmTilt;
        tsHeight:
            Result := tmHeight;
        tsLegSupt:
            Result := tmLegSupt;
        tsSwivel:
            Result := tmSwivel;
    else
        raise Exception.CreateFmt('Invalid TTsOrd value: %d', [Ord(Ts)]);
    end;
end;

function IsBwdRO(RO: TResultOrd): Boolean;
begin
    Result := RO in [roDataBwCurr, roDataBwSpeed, roDataBwInitNoise, roDataBwRunNoise, roDataBwInitNoiseDev, roDataBwRunNoiseDev];
end;

//------------------------------------------------------------------------------
{ TDeliveryPos }

function TDeliveryPos.GetDir: TMotorWayOrd;
begin
    case rPos of
        0:
            Result := twForw;
        1:
            Result := twBack;
        2:
            Result := rWay;
    end;
end;

function TDeliveryPos.InRange(Val, Margin: Double): Boolean;
begin
    Result := ((rMin - Margin) <= Val) and (Val <= (rMax + Margin));
end;

function TDeliveryPos.GetTime: Double;
begin
    case rPos of
        0:
            Result := 0;
        1:
            Result := 0;
        2:
            Result := rTime;
    end;
end;


{ TModel }

function TModel.IsEmpty: Boolean;
begin
    Result := rIndex <= 0;
end;

procedure TModel.Read(DataSet: TDataSet; RWEvent: TDataSetRWEvent);
begin
    rIndex := 0;            // Spec ???? ?????? Flag?? ???

    rPartNo := DataSet.FieldByName('part_no').AsString;
    rLclPartNo := DataSet.FieldByName('lcl_part_no').AsString;
    rPartName := DataSet.FieldByName('part_name').AsString;
    rTypes.mDataBits := DataSet.FieldByName('type_bits').AsLargeInt;
    rSPITypeBits := DataSet.FieldByName('spi_type_bits').AsLargeInt;

    if Assigned(RWEvent) then
        RWEvent(DataSet);
end;

procedure TModel.ReadAsOpt(ChkListBox: TCheckListBox);
begin
    SeatTypeUI.ReadAsOpt(rTypes, ChkListBox);
end;

procedure TModel.ReadAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
begin
    //SeatTypeUI.ReadAsType(rTypes, PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG);
end;

function TModel.Write(DataSet: TDataSet; IsAppend: Boolean; RWEvent: TDataSetRWEvent): Boolean;
begin
    Result := True;
    try

        if IsAppend then
            DataSet.Append
        else
            DataSet.Edit;

        DataSet.FieldByName('part_no').AsString := rPartNo;
        DataSet.FieldByName('lcl_part_no').AsString := rLclPartNo;
        DataSet.FieldByName('part_name').AsString := rPartName;
        DataSet.FieldByName('type_bits').AsLargeInt := rTypes.mDataBits;
        DataSet.FieldByName('spi_type_bits').AsLargeInt := rSPITypeBits;

        if Assigned(RWEvent) then
        begin
            if not RWEvent(DataSet) then
            begin
                Exit(False);
            end;
        end;

        DataSet.Post;

        if IsAppend then
            DataSet.Last;

    except
        on e: EDatabaseError do
        begin
            gLog.Panel(e.ToString);
            ShowMessage(e.ToString);
            DataSet.Cancel;
            Exit(False);
        end;
    end;

end;

procedure TModel.Write(Strings: TStrings; StartCol: Integer);
var
    MT: TModelType;
begin
    Strings.Strings[StartCol + 0] := rPartNo;
    Strings.Strings[StartCol + 1] := rLclPartNo;
    rTypes.WriteAsType(Strings, 2);
end;

procedure TModel.WriteAsOpt(ChkListBox: TCheckListBox);
begin
    SeatTypeUI.WriteAsOpt(rTypes, ChkListBox);
end;

procedure TModel.WriteAsType(PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG: TRadioGroup);
begin
    //SeatTypeUI.WriteAsType(rTypes, PosRG, CarTypeRG, SeatTypeRG, DrvTypeRG);
end;

{ TMotorData }

procedure TMotorData.Clear;
begin
    FillChar(rItems[twForw], Sizeof(TMotorTestItem), 0);
    FillChar(rItems[twBack], Sizeof(TMotorTestItem), 0);
    rLimit := False;
end;



{ TMsgData }

procedure TMsgData.Init(Caption, Msg1, Msg2: string);
begin
    mCaption := Caption;
    mMsg1 := Msg1;
    mMsg2 := Msg2;
end;

{ TMdlExData }

constructor TMdlExData.Create(ID: Integer; TypeBits: DWORD);
begin
    mID := ID;
    mTypeBits := TypeBits;
end;

function TMdlExData.ToKeyStr: string;
begin
    Result := Format('%d.%X', [mID, mTypeBits]);
end;

function TMdlExData.Write(FileHandle: Integer): Boolean;
begin
    Result := FileWrite(FileHandle, self, sizeof(TMdlExData)) = sizeof(TMdlExData);
end;


{ TTsOrdJudge }

function TTsOrdJudge.GetJudgeStr: string;
begin
    Result := JudgeToStr(mJudge);
end;

{ TTsOrdJudgeList }

function TTsOrdJudgeList.Add(Item: TTsOrdJudge): Integer;
begin
    Result := inherited Add(Item);
end;

function TTsOrdJudgeList.IndexOf(Item: TTsORD): Integer;
var
    i: Integer;
begin
    for i := 0 to Self.Count - 1 do
    begin
        if Items[i].mTsOrd = Item then
            Exit(i);
    end;

    Result := -1;
end;


{ TMotorSpec }

procedure TMotorSpec.Init;
begin
    rCurr.mUnitStr := 'A';
    rSpeed[twForw].mUnitStr := 'mm/s';
    rSpeed[twBack].mUnitStr := 'mm/s';
    rTime.mUnitStr := 's';
end;

{ TSpecs }

function TSpecs.ToMotorStr(MtrOrd: TMotorOrd; RO: TResultOrd; IsUnit: Boolean): string;
begin
    case RO of
        rospecCurrLo:
            begin
                rMotors[MtrOrd].rCurr.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rCurr.ToMinStr;
            end;
        rospecCurrHi:
            begin
                rMotors[MtrOrd].rCurr.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rCurr.ToMaxStr;
            end;

        rospecCurrHiLo:
            begin
                rMotors[MtrOrd].rCurr.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rCurr.ToStr;
            end;

        rospecTimeLo:
            begin
                rMotors[MtrOrd].rTime.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rTime.ToMinStr;
            end;

        rospecTimeHi:
            begin
                rMotors[MtrOrd].rTime.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rTime.ToMaxStr;
            end;

        rospecTimeHiLo:
            begin
                rMotors[MtrOrd].rTime.mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rTime.ToStr;
            end;

        rospecFwSpeedLo:
            begin
                rMotors[MtrOrd].rSpeed[twForw].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twForw].ToMinStr(FORMAT_SPEED);
            end;

        rospecFwSpeedHi:
            begin
                rMotors[MtrOrd].rSpeed[twForw].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twForw].ToMaxStr(FORMAT_SPEED);
            end;

        rospecFwSpeedHiLo:
            begin
                rMotors[MtrOrd].rSpeed[twForw].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twForw].ToStrWithUnit(FORMAT_SPEED);
            end;
        rospecBwSpeedLo:
            begin
                rMotors[MtrOrd].rSpeed[twBack].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twBack].ToMinStr(FORMAT_SPEED);
            end;

        rospecBwSpeedHi:
            begin
                rMotors[MtrOrd].rSpeed[twBack].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twBack].ToMaxStr(FORMAT_SPEED);
            end;

        rospecBwSpeedHiLo:
            begin
                rMotors[MtrOrd].rSpeed[twBack].mShowUnit := IsUnit;
                Result := rMotors[MtrOrd].rSpeed[twBack].ToStrWithUnit(FORMAT_SPEED);
            end;

        rospecInitNoiseHi:
            begin
                Result := '~ ' + FormatFloat('0.0', rMotors[MtrOrd].rInitNoise);
                if IsUnit then
                    Result := Result + ' dB';
            end;
        rospecRunNoiseHi:
            begin
                Result := '~ ' + FormatFloat('0.0', rMotors[MtrOrd].rInitNoise);
                if IsUnit then
                    Result := Result + ' dB';
            end;

    end;
end;

procedure TSpecs.Init;
var
    Mtr: TMotorOrd;
begin
    for Mtr := Low(TMotorOrd) to MtrOrdHi do
        rMotors[Mtr].Init;

    rAncPTReg.mUnitStr := '??';
    rBuckleCurr.mUnitStr := 'mA';
end;



{ TEcuInfo }

constructor TEcuInfo.Create(const APartNo, ASwVer, AHwVer: string);
begin
    rPartNo := APartNo;
    rSwVer := ASwVer;
    rHwVer := AHwVer;
end;

function TEcuInfo.ToStr: string;
begin
    Result := Format('PartNo: %s, SwVer: %s, HwVer: %s', [rPartNo, rSwVer, rHwVer]);
end;

function TEcuInfo.Equals(const Other: TEcuInfo): Boolean;
begin
    Result := ComparePartNo(Other.rPartNo) and CompareSwVer(Other.rSwVer) and CompareHwVer(Other.rHwVer);
end;

function TEcuInfo.ComparePartNo(const Target: string): Boolean;
begin
    Result := (Pos('MASTER', rPartNo) > 0) or (Pos(Target, rPartNo) > 0);
end;

function TEcuInfo.CompareSwVer(const Target: string): Boolean;
begin
    Result := (Pos('MASTER', rSwVer) > 0) or (Pos(Target, rSwVer) > 0);
end;

function TEcuInfo.CompareHwVer(const Target: string): Boolean;
begin
    Result := (Pos('MASTER', rHwVer) > 0) or (Pos(Target, rHwVer) > 0);
end;


{ TResult }

procedure TResult.Clear(IncModel: Boolean);
var
    TempMdl: TModel;
begin

    Move(rModel, TempMdl, sizeof(TModel));

    ZeroMemory(@self, sizeof(TResult));

    if not IncModel then
        Move(TempMdl, RModel, sizeof(TModel));


    rModel.rSpecs.Init;

    rBCFilePos := -1;
end;

function TResult.GetBlowPos: THVPosType;
begin
    if rModel.rTypes.IsLHAsHost then
        Result := hvpDrv
    else
        Result := hvpPsg;
end;

function TResult.ModelToStr(RO: TResultOrd; IsUnit: Boolean): string;
begin
    with rModel do
    begin
        case RO of
            roIndex:
                Result := Format('%0.2d', [rIndex]);

            roPosType:
                Result := TPOS_TYPE_STR[BYTE(rTypes.GetPosType)];
            roPosExType:
                Result := rTypes.GetPosStr;
            roCarType:
                Result := TCAR_TYPE_STR[BYTE(rTypes.GetCarType)];
            roPartName:
                Result := rPartName;
            roPartNo:
                Result := rPartNo;
            roLclPartNo:
                Result := string(rLclPartNo);
                // ???? ????
            rospecCurrLo, rospecCurrHi, rospecCurrHiLo, rospecTimeLo, rospecTimeHi, rospecTimeHiLo, rospecInitNoiseHi, rospecRunNoiseHi, rospecFwSpeedLo, rospecFwSpeedHi, rospecFwSpeedHiLo, rospecBwSpeedLo, rospecBwSpeedHi, rospecBwSpeedHiLo:
                begin
                    Result := rModel.rSpecs.ToMotorStr(rCurMtr, RO, IsUnit);
                end;
        end;
    end;
end;

procedure TResult.SetCurHVIdx(HVPos: THVPosType; HVTestType: THVTestType);
begin
    rCurHVPos := HVPos;
    rCurHVTestType := HVTestType;
end;

{ TOutPosInfo }

function TOutPosInfo.IsIn(Dis1, Dis2: Double): Boolean;
begin
    case mSensorIdx of
        0:
            Result := mSpec[0].IsIn(Dis1);
        1:
            Result := mSpec[1].IsIn(Dis2);
        2:
            Result := mSpec[0].IsIn(Dis1) or mSpec[1].IsIn(Dis2);
        3:
            Result := mSpec[0].IsIn(Dis1) and mSpec[1].IsIn(Dis2);
    else
        Result := mSpec[0].IsIn(Dis1);
    end;
end;

{ TOutPos }

function TOutPos.GetDir: TMotorDir;
begin
    case rType of
        0:
            Result := twForw;
        1:
            Result := twBack;
        2:
            Result := rDir4Time;
    else
        Result := twBack;
    end;
end;

function TOutPos.GetTime: single;
begin
    case rType of
        2:
            Result := rTime;
    else
        Result := 0.0;
    end;

end;

{ TMotorConstraints }

function TMotorConstraints.IsMoveByTime: Boolean;
begin
    Result := rMethodIdx = 1;
end;

{ TOffset }

function TOffset.GetHVOffset(HVTestType: THVTestType): Double;
begin
    case HVTestType of
        hvtHeat:
            Result := rVals[ucHeat];
        hvtVent:
            Result := rVals[ucVent];
    end;
end;

initialization
    gSysEnv.LoadAll;

    gSysEnv.rOP.rVer := '250626.00';

    TLangTran.Init(ltKor, TLangType(gSysEnv.rOP.rLanguage));

{$IFNDEF _VIEWER}
    lpUsrstdDate := EncodeDate(2014, 06, 01);
    LoadLastCount;



    // LoadDeliveryPos ;
    gCycleTime[0] := 0;
    gCycleTime[1] := 0;


{$ENDIF}

end.

