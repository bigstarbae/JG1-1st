unit SOEMParams;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 2024-02-05                                            }
{    Generated Time: ¿ÀÈÄ 5:07:12                                              }
{                                                                          }
{**************************************************************************}

interface

uses
    SysUtils,
{$IFDEF WIN32}
    Windows;
{$ENDIF}



{$IFDEF __cplusplus}
{$ENDIF}

{+//* max entries in Object Description list*/ }

const
    EC_MAXODLIST = 1024;
    EC_MAXELIST = 64;
    EC_MAXNAME = 40;
    EC_MAXSLAVE = 200;
    EC_MAXGROUP = 2;
    EC_MAXIOSEGMENTS = 64;
    EC_MAXMBX = 1486;
    EC_MAXEEPDO = $200;
    EC_MAXSM = 8;
    EC_MAXFMMU = 4;
    EC_MAXLEN_ADAPTERNAME = 128;
    EC_MAX_MAPT = 1;
    EC_MAXOELIST = 256;

  // return value no frame returned
    EC_NOFRAME = -1;
  // return value unknown frame received
    EC_OTHERFRAME = -2;
  // return value general error
    EC_ERROR = -3;
  // return value too many slaves
    EC_SLAVECOUNTEXCEEDED = -4;
  // return value request timeout
    EC_TIMEOUT = -5;
  // maximum EtherCAT frame length in bytes
    EC_MAXECATFRAME = 1518;
  // maximum EtherCAT LRW frame length in bytes
  // MTU - Ethernet header - length - datagram header - WCK - FCS
    EC_MAXLRWDATA = (EC_MAXECATFRAME - 14 - 2 - 10 - 2 - 4);
  // size of DC datagram used in first LRW frame
    EC_FIRSTDCDATAGRAM = 20;
  // standard frame buffer size in bytes
    EC_BUFSIZE = EC_MAXECATFRAME;
  // datagram type EtherCAT
    EC_ECATTYPE = $1000;
  // number of frame buffers per channel (tx, rx1 rx2)
    EC_MAXBUF = 16;
  // timeout value in us for tx frame to return to rx
    EC_TIMEOUTRET = 2000;
  // timeout value in us for safe data transfer, max. triple retry
    EC_TIMEOUTRET3 = (EC_TIMEOUTRET * 3);
  // timeout value in us for return "safe" variant (f.e. wireless)
    EC_TIMEOUTSAFE = 20000;
  // timeout value in us for EEPROM access
    EC_TIMEOUTEEP = 20000;
  // timeout value in us for tx mailbox cycle
    EC_TIMEOUTTXM = 20000;
  // timeout value in us for rx mailbox cycle
    EC_TIMEOUTRXM = 700000;
  // timeout value in us for check statechange
    EC_TIMEOUTSTATE = 2000000;
  // size of EEPROM bitmap cache
    EC_MAXEEPBITMAP = 128;
  // size of EEPROM cache buffer
    EC_MAXEEPBUF = EC_MAXEEPBITMAP shl 5;
  // default number of retries if wkc <= 0
    EC_DEFAULTRETRIES = 3;
  // default group size in 2^x
    EC_LOGGROUPOFFSET = 16;



  // SII category strings
    ECT_SII_STRING = 10;
  // SII category general
    ECT_SII_GENERAL = 30;
  // SII category FMMU
    ECT_SII_FMMU = 40;
  // SII category SM
    ECT_SII_SM = 41;
  // SII category PDO
    ECT_SII_PDO = 50;

  // Item offsets in SII general section
    ECT_SII_MANUF = $0008;
    ECT_SII_ID = $000A;
    ECT_SII_REV = $000C;
    ECT_SII_BOOTRXMBX = $0014;
    ECT_SII_BOOTTXMBX = $0016;
    ECT_SII_MBXSIZE = $0019;
    ECT_SII_TXMBXADR = $001A;
    ECT_SII_RXMBXADR = $0018;
    ECT_SII_MBXPROTO = $001C;

  // Mailbox types definitions
    ECT_MBXT_ERR = $00; // Error mailbox type
    ECT_MBXT_AOE = $01; // ADS over EtherCAT mailbox type
    ECT_MBXT_EOE = $02; // Ethernet over EtherCAT mailbox type
    ECT_MBXT_COE = $03; // CANopen over EtherCAT mailbox type
    ECT_MBXT_FOE = $04; // File over EtherCAT mailbox type
    ECT_MBXT_SOE = $05; // Servo over EtherCAT mailbox type
    ECT_MBXT_VOE = $0F; // Vendor over EtherCAT mailbox type

  // CoE mailbox types
    ECT_COES_EMERGENCY = $01;
    ECT_COES_SDOREQ = $02;
    ECT_COES_SDORES = $03;
    ECT_COES_TXPDO = $04;
    ECT_COES_RXPDO = $05;
    ECT_COES_TXPDO_RR = $06;
    ECT_COES_RXPDO_RR = $07;
    ECT_COES_SDOINFO = $08;

  // CoE SDO commands
    ECT_SDO_DOWN_INIT = $21;
    ECT_SDO_DOWN_EXP = $23;
    ECT_SDO_DOWN_INIT_CA = $31;
    ECT_SDO_UP_REQ = $40;
    ECT_SDO_UP_REQ_CA = $50;
    ECT_SDO_SEG_UP_REQ = $60;
    ECT_SDO_ABORT = $80;

  // CoE Object Description commands
    ECT_GET_ODLIST_REQ = $01;
    ECT_GET_ODLIST_RES = $02;
    ECT_GET_OD_REQ = $03;
    ECT_GET_OD_RES = $04;
    ECT_GET_OE_REQ = $05;
    ECT_GET_OE_RES = $06;
    ECT_SDOINFO_ERROR = $07;

  // FoE opcodes
    ECT_FOE_READ = $01;
    ECT_FOE_WRITE = $02;
    ECT_FOE_DATA = $03;
    ECT_FOE_ACK = $04;
    ECT_FOE_ERROR = $05;
    ECT_FOE_BUSY = $06;

  // SoE opcodes
    ECT_SOE_READREQ = $01;
    ECT_SOE_READRES = $02;
    ECT_SOE_WRITEREQ = $03;
    ECT_SOE_WRITERES = $04;
    ECT_SOE_NOTIFICATION = $05;
    ECT_SOE_EMERGENCY = $06;

  // Ethercat registers
    ECT_REG_TYPE = $0000;
    ECT_REG_PORTDES = $0007;
    ECT_REG_ESCSUP = $0008;
    ECT_REG_STADR = $0010;
    ECT_REG_ALIAS = $0012;
    ECT_REG_DLCTL = $0100;
    ECT_REG_DLPORT = $0101;
    ECT_REG_DLALIAS = $0103;
    ECT_REG_DLSTAT = $0110;
    ECT_REG_ALCTL = $0120;
    ECT_REG_ALSTAT = $0130;
    ECT_REG_ALSTATCODE = $0134;
    ECT_REG_PDICTL = $0140;
    ECT_REG_IRQMASK = $0200;
    ECT_REG_RXERR = $0300;
    ECT_REG_FRXERR = $0308;
    ECT_REG_EPUECNT = $030C;
    ECT_REG_PECNT = $030D;
    ECT_REG_PECODE = $030E;
    ECT_REG_LLCNT = $0310;
    ECT_REG_WDCNT = $0442;
    ECT_REG_EEPCFG = $0500;
    ECT_REG_EEPCTL = $0502;
    ECT_REG_EEPSTAT = $0502;
    ECT_REG_EEPADR = $0504;
    ECT_REG_EEPDAT = $0508;
    ECT_REG_FMMU0 = $0600;
    ECT_REG_FMMU1 = ECT_REG_FMMU0 + $10;
    ECT_REG_FMMU2 = ECT_REG_FMMU1 + $10;
    ECT_REG_FMMU3 = ECT_REG_FMMU2 + $10;
    ECT_REG_SM0 = $0800;
    ECT_REG_SM1 = ECT_REG_SM0 + $08;
    ECT_REG_SM2 = ECT_REG_SM1 + $08;
    ECT_REG_SM3 = ECT_REG_SM2 + $08;
    ECT_REG_SM0STAT = ECT_REG_SM0 + $05;
    ECT_REG_SM1STAT = ECT_REG_SM1 + $05;
    ECT_REG_SM1ACT = ECT_REG_SM1 + $06;
    ECT_REG_SM1CONTR = ECT_REG_SM1 + $07;
    ECT_REG_DCTIME0 = $0900;
    ECT_REG_DCTIME1 = $0904;
    ECT_REG_DCTIME2 = $0908;
    ECT_REG_DCTIME3 = $090C;
    ECT_REG_DCSYSTIME = $0910;
    ECT_REG_DCSOF = $0918;
    ECT_REG_DCSYSOFFSET = $0920;
    ECT_REG_DCSYSDELAY = $0928;
    ECT_REG_DCSYSDIFF = $092C;
    ECT_REG_DCSPEEDCNT = $0930;
    ECT_REG_DCTIMEFILT = $0934;
    ECT_REG_DCCUC = $0980;
    ECT_REG_DCSYNCACT = $0981;
    ECT_REG_DCSTART0 = $0990;
    ECT_REG_DCCYCLE0 = $09A0;
    ECT_REG_DCCYCLE1 = $09A4;

  // standard SDO Sync Manager Communication Type
    ECT_SDO_SMCOMMTYPE = $1C00;
  // standard SDO PDO assignment
    ECT_SDO_PDOASSIGN = $1C10;
  // standard SDO RxPDO assignment
    ECT_SDO_RXPDOASSIGN = $1C12;
  // standard SDO TxPDO assignment
    ECT_SDO_TXPDOASSIGN = $1C13;

  // Ethercat packet type
    ETH_P_ECAT = $88A4;

    ECT_ALL_SLAVES_OP_STATE = 0;
    ECT_NO_SLAVE_FOUND = 1;
    ECT_NOT_ALL_OP_STATE = 2;

    // AL Status Codes
    AL_NO_ERROR = $0000;
    AL_UNSPEC_ERROR = $0001;
    AL_INVALID_STATE_CHANGE = $0011;
    AL_UNKNOWN_REQ_STATE = $0012;
    AL_BOOTSTRAP_NOT_SUPPORTED = $0013;
    AL_NO_VALID_FIRMWARE = $0014;
    AL_INVALID_MAILBOX_CONFIG1 = $0015;
    AL_INVALID_MAILBOX_CONFIG2 = $0016;
    AL_INVALID_SM_CONFIG = $0017;
    AL_NO_VALID_INPUTS_AVAILABLE = $0018;
    AL_NO_VALID_OUTPUTS_AVAILABLE = $0019;
    AL_SYNC_ERROR = $001A;
    AL_WATCHDOG_ERROR = $001B;
    AL_INVALID_SM_TYPE = $001C;
    AL_INVALID_OUTPUT_CONFIG = $001D;
    AL_INVALID_INPUT_CONFIG = $001E;
    AL_INVALID_WATCHDOG_CONFIG = $001F;
    AL_SLAVE_NEEDS_COLD_START = $0020;
    AL_SLAVE_NEED_INIT = $0021;
    AL_SLAVE_NEED_PRE_OP = $0022;
    AL_SLAVE_NEEDS_SAFE_OP = $0023;
    AL_INVALID_OUTPUT_FMMU_CONFIG = $002D;
    AL_INVALID_INPUT_FMMU_CONFIG = $002E;
    AL_INVALID_DC_SYNCH = $0030;
    AL_INVALID_DC_LATCH = $0031;
    AL_PLL_ERROR = $0032;
    AL_INVALID_DC_IO = $0033;
    AL_INVALID_DC_TIMEOUT = $0034;

    // BC State Code
    BC_NO_ERROR = $0000;


    // EtherCAT slave State
    EC_STATE_NONE = $00;
    EC_STATE_INIT = $01;
    EC_STATE_PRE_OP = $02;
    EC_STATE_BOOT = $03;
    EC_STATE_SAFE_OP = $04;
    EC_STATE_OPERATIONAL = $08;
    EC_STATE_ACK = $10;
    EC_STATE_ERROR = $10;

    TRY_SHUT_DOWN_RECOVER = 10;
{+// Storage for object description list*/ }

type
    pec_buf = ^ec_buf;

    ec_buf = array[0..EC_BUFSIZE - 1] of Byte;
  //

  // Possible error codes returned.
    ec_err = (EC_ERR_OK = 0, EC_ERR_ALREADY_INITIALIZED, EC_ERR_NOT_INITIALIZED, EC_ERR_TIMEOUT, EC_ERR_NO_SLAVES, EC_ERR_NOK);


  // Possible buffer states
    ec_bufstate = (EC_BUF_EMPTY = $00, EC_BUF_ALLOC = $01, EC_BUF_TX = $02, EC_BUF_RCVD = $03, EC_BUF_COMPLETE = $04);

  // Ethercat data types
    ec_datatype = (ECT_BOOLEAN = $0001, ECT_INTEGER8 = $0002, ECT_INTEGER16 = $0003, ECT_INTEGER32 = $0004, ECT_UNSIGNED8 = $0005, ECT_UNSIGNED16 = $0006, ECT_UNSIGNED32 = $0007, ECT_REAL32 = $0008, ECT_VISIBLE_STRING = $0009, ECT_OCTET_STRING = $000A, ECT_UNICODE_STRING = $000B, ECT_TIME_OF_DAY = $000C, ECT_TIME_DIFFERENCE = $000D, ECT_DOMAIN = $000F, ECT_INTEGER24 = $0010, ECT_REAL64 = $0011, ECT_INTEGER64 = $0015, ECT_UNSIGNED24 = $0016, ECT_UNSIGNED64 = $001B, ECT_BIT1 = $0030, ECT_BIT2 = $0031, ECT_BIT3 = $0032, ECT_BIT4 = $0033, ECT_BIT5 = $0034, ECT_BIT6 = $0035, ECT_BIT7 = $0036, ECT_BIT8 = $0037);

  // Ethercat command types
    ec_cmdtype = (EC_CMD_NOP = $00, EC_CMD_APRD, EC_CMD_APWR, EC_CMD_APRW, EC_CMD_FPRD, EC_CMD_FPWR, EC_CMD_FPRW, EC_CMD_BRD, EC_CMD_BWR, EC_CMD_BRW, EC_CMD_LRD, EC_CMD_LWR, EC_CMD_LRW, EC_CMD_ARMW, EC_CMD_FRMW);

  // Ethercat EEprom command types
    ec_ecmdtype = (EC_ECMD_NOP = $0000, EC_ECMD_READ = $0100, EC_ECMD_WRITE = $0201, EC_ECMD_RELOAD = $0300);

  // Error types
    ec_err_type = (EC_ERR_TYPE_SDO_ERROR, EC_ERR_TYPE_EMERGENCY, EC_ERR_TYPE_PACKET_ERROR, EC_ERR_TYPE_SDOINFO_ERROR, EC_ERR_TYPE_FOE_ERROR, EC_ERR_TYPE_FOE_BUF2SMALL, EC_ERR_TYPE_FOE_PACKETNUMBER, EC_ERR_TYPE_SOE_ERROR, EC_ERR_TYPE_MBX_ERROR, EC_ERR_TYPE_FOE_FILE_NOTFOUND, EC_ERR_TYPE_EOE_INVALID_RX_DATA);

    ec_checkstate = (ECS_NONE = 0, ECS_SAFEOP_ERROR_ATTEMPT_ACK = 1, ECS_SAFEOP_CHANGE_OPERATIONAL = 2, ECS_SLAVE_RECONFIGED = 3,
                     ECS_SLAVE_LOST = 4, ECS_SLAVE_RECOVERED = 5, ECS_SLAVE_FOUND = 6, ECS_SLAVE_OK = 7);

    ec_timet = record
        sec: Cardinal;  // Seconds elapsed since the Epoch (Jan 1, 1970)
        usec: Cardinal; // Microseconds elapsed since last second boundary
    end;

    ec_etherheadert = packed record
        da0, da1, da2: Word; // destination MAC
        sa0, sa1, sa2: Word; // source MAC
        etype: Word;         // ethernet type
    end;

    ec_comt = packed record
        elength: Word;  // length of EtherCAT datagram
        command: Byte;  // EtherCAT command, see ec_cmdtype
        index: Byte;    // index, used in SOEM for Tx to Rx recombination
        ADP: Word;      // ADP
        ADO: Word;      // ADO
        dlength: Word;  // length of data portion in datagram
        irpt: Word;     // interrupt, currently unused
    end;

    ec_errort = record
        Time: ec_timet;     // Time at which the error was generated
        Signal: Boolean;    // Signal bit, error set but not read
        Slave: Word;        // Slave number that generated the error
        Index: Word;        // CoE SDO index that generated the error
        SubIdx: Byte;       // CoE SDO subindex that generated the error
        Etype: ec_err_type; // Type of error
        case Integer of
            0:
                (AbortCode: Int32); // General abortcode
            1:
                (ErrorCode: Word;   // Specific error for Emergency mailbox
                ErrorReg: Byte;
                b1: Byte;
                w1: Word;
                w2: Word);
    end;

    pecx_context = ^ecx_context;

    ec_adapter = record
        name: array[0..EC_MAXLEN_ADAPTERNAME - 1] of AnsiChar;
        desc: array[0..EC_MAXLEN_ADAPTERNAME - 1] of AnsiChar;
        next: ^ec_adapter;
    end;

    ec_fmmu = packed record
        LogStart: DWord;
        LogLength: Word;
        LogStartbit: Byte;
        LogEndbit: Byte;
        PhysStart: Word;
        PhysStartBit: Byte;
        FMMUtype: Byte;
        FMMUactive: Byte;
        unused1: Byte;
        unused2: Word;
    end;

    ec_sm = packed record
        StartAddr: Word;
        SMlength: Word;
        SMflags: DWord;
    end;

    ec_state_status = packed record
        State: Word;
        Unused: Word;
        ALstatuscode: Word;
    end;

    TPO2SOconfig = function(slave: word): Integer; cdecl;

    TPO2SOconfigx = function(context: pecx_context; slave: word): Integer; cdecl;

    ec_slave = record
        state: Word;
        ALstatuscode: Word;
        configadr: Word;
        aliasadr: Word;
        eep_man: DWord;
        eep_id: DWord;
        eep_rev: DWord;
        Itype: Word;
        Dtype: Word;
        Obits: Word;
        Obytes: DWord;
        outputs: PByte;
        Ostartbit: Byte;
        Ibits: Word;
        Ibytes: DWord;
        inputs: PByte;
        Istartbit: Byte;
        SM: array[0..EC_MAXSM - 1] of ec_sm;
        SMtype: array[0..EC_MAXSM - 1] of Byte;
        FMMU: array[0..EC_MAXFMMU - 1] of ec_fmmu;
        FMMU0func: Byte;
        FMMU1func: Byte;
        FMMU2func: Byte;
        FMMU3func: Byte;
        mbx_l: Word;
        mbx_wo: Word;
        mbx_rl: Word;
        mbx_ro: Word;
        mbx_proto: Word;
        mbx_cnt: Byte;
        hasdc: Boolean;
        ptype: Byte;
        topology: Byte;
        activeports: Byte;
        consumedports: Byte;
        parent: Word;
        parentport: Byte;
        entryport: Byte;
        DCrtA: Int32;
        DCrtB: Int32;
        DCrtC: Int32;
        DCrtD: Int32;
        pdelay: Int32;
        DCnext: Word;
        DCprevious: Word;
        DCcycle: Int32;
        DCshift: Int32;
        DCactive: Byte;
        configindex: Word;
        SIIindex: Word;
        eep_8byte: Byte;
        eep_pdi: Byte;
        CoEdetails: Byte;
        FoEdetails: Byte;
        EoEdetails: Byte;
        SoEdetails: Byte;
        Ebuscurrent: Int16;
        blockLRW: Byte;
        group: Byte;
        FMMUunused: Byte;
        islost: Boolean;
        PO2SOConfig: ^TPO2SOconfig;
        PO2SOConfigx: ^TPO2SOconfigx;
        name: array[0..EC_MAXNAME + 1] of AnsiChar;
    end;

    pec_slave = ^ec_slave;

    ec_slavet = array[0..EC_MAXSLAVE - 1] of ec_slave;

    pec_slavet = ^ec_slavet;

    ec_group = record
        logstartaddr: DWord;
        Obytes: DWord;
        outputs: PByte;
        Ibytes: DWord;
        inputs: PByte;
        hasdc: Boolean;
        DCnext: Word;
        Ebuscurrent: Int16;
        blockLRW: Byte;
        nsegments: Word;
        Isegment: Word;
        Ioffset: Word;
        outputsWKC: Word;
        inputsWKC: Word;
        docheckstate: Boolean;
        IOsegment: array[0..EC_MAXIOSEGMENTS - 1] of DWord;
    end;

    pec_group = ^ec_group;

    ec_groupt = array[0..EC_MAXGROUP - 1] of ec_group;

    pec_groupt = ^ec_groupt;

    pec_eepromFMMU = ^ec_eepromFMMU;

    ec_eepromFMMU = record
        Startpos: Word;
        nFMMU: Byte;
        FMMU0: Byte;
        FMMU1: Byte;
        FMMU2: Byte;
        FMMU3: Byte;
    end;

    pec_eepromSM = ^ec_eepromSM;

    ec_eepromSM = record
        Startpos: Word;
        nSM: Byte;
        PhStart: Word;
        Plength: Word;
        Creg: Byte;
        Sreg: Byte;
        Activate: Byte;
        PDIctrl: Byte;
    end;

    ec_eepromPDO = record
        Startpos: Word;
        Length: Word;
        nPDO: Word;
        Index: array[0..EC_MAXEEPDO - 1] of Word;
        SyncM: array[0..EC_MAXEEPDO - 1] of Word;
        BitSize: array[0..EC_MAXEEPDO - 1] of Word;
        SMbitsize: array[0..EC_MAXSM - 1] of Word;
    end;

    ec_mbxbuft = array[0..EC_MAXMBX - 1] of Byte;

    ec_mbxheader = packed record
        length: Word;
        address: Word;
        priority: Byte;
        mbxtype: Byte;
    end;

    ec_alstatus = packed record
        alstatus: Word;
        unused: Word;
        alstatuscode: Word;
    end;

    pec_idxstack = ^ec_idxstack;

    ec_idxstack = record
        pushed: Byte;
        pulled: Byte;
        idx: array[0..EC_MAXBUF - 1] of Byte;
        data: array[0..EC_MAXBUF - 1] of Pointer;
        length: array[0..EC_MAXBUF - 1] of Word;
        dcoffset: array[0..EC_MAXBUF - 1] of Word;
    end;

    pec_ering = ^ec_ering;

    ec_ering = record
        head: Int16;
        tail: Int16;
        Error: array[0..EC_MAXELIST - 1] of ec_errort;
    end;

    ec_SMcommtype = packed record
        n: Byte;
        nu1: Byte;
        SMtype: array[0..EC_MAXSM - 1] of Byte;
    end;

    pec_SMcommtype = ^ec_SMcommtype;

    ec_SMcommTypet = array[0..EC_MAX_MAPT - 1] of ec_SMcommtype;

    pec_SMcommTypet = ^ec_SMcommTypet;

    ec_PDOassign = packed record
        n: Byte;
        nu1: Byte;
        index: array[0..255] of Word;
    end;

    pec_PDOassign = ^ec_PDOassign;

    ec_PDOassignt = array[0..EC_MAX_MAPT - 1] of ec_PDOassign;

    pec_PDOassignt = ^ec_PDOassignt;

    ec_PDOdesc = packed record
        n: Byte;
        nu1: Byte;
        PDO: array[0..255] of DWord;
    end;

    pec_PDOdesc = ^ec_PDOdesc;

    ec_PDOdesct = array[0..EC_MAX_MAPT - 1] of ec_PDOdesc;

    pec_PDOdesct = ^ec_PDOdesct;

    ec_stack = record
        sock: ^Pointer;
        txbuf: array[0..EC_MAXBUF - 1] of pec_buf;
        txbuflength: array[0..EC_MAXBUF - 1] of PInteger;
        tempbuf: pec_buf;
        rxbuf: array[0..EC_MAXBUF - 1] of pec_buf;
        rxbufstat: array[0..EC_MAXBUF - 1] of PInteger;
        rxsa: array[0..EC_MAXBUF - 1] of PInteger;
    end;

    pecx_redport = ^ecx_redport;

    ecx_redport = record
        stack: ec_stack;
        sockhandle: Pointer;

        rxbuf: array[0..EC_MAXBUF - 1] of ec_buf;
        rxbufstat: array[0..EC_MAXBUF - 1] of Integer;
        rxsa: array[0..EC_MAXBUF - 1] of Integer;

        tempinbuf: ec_buf;
    end;

    pecx_port = ^ecx_port;

    ecx_port = record
        stack: ec_stack;
        sockhandle: Pointer; // Assuming pcap_t is a pointer type
        rxbuf: array[0..EC_MAXBUF - 1] of ec_buf;
        rxbufstat: array[0..EC_MAXBUF - 1] of Integer;
        rxsa: array[0..EC_MAXBUF - 1] of Integer;
        tempinbuf: ec_buf;
        tempinbufs: Integer;
        txbuf: array[0..EC_MAXBUF - 1] of ec_buf;
        txbuflength: array[0..EC_MAXBUF - 1] of Integer;
        txbuf2: ec_buf;
        txbuflength2: Integer;
        lastidx: Byte;
        redstate: Integer;
        redport: pecx_redport; // Assuming ecx_redportt is a pointer type
        getindex_mutex: TRTLCriticalSection;
        tx_mutex: TRTLCriticalSection;
        rx_mutex: TRTLCriticalSection;
    end;

    ppcap_t = ^pcap_t;

    pcap_t = record
    end;

    ec_esibuf = array[0..EC_MAXEEPBUF - 1] of Byte;

    pec_esibuf = ^ec_esibuf;

    ec_simap = array[0..EC_MAXEEPBITMAP - 1] of DWORD;

    pec_simap = ^ec_simap;

    TFOEhook = function(slave: Word; packetnumber, datasize: Integer): Integer;

    TEOEhook = function(context: pecx_context; slave: Word; eoembx: Pointer): Integer;

    ecx_context = record
        port: pecx_port;
        slavelist: pec_slavet;
        slavecount: PInteger;
        maxslave: Integer;
        grouplist: pec_groupt;
        maxgroup: Integer;
        esibuf: pByte;
        esimap: pDWord;
        esislave: Word;
        elist: pec_ering;
        idxstack: pec_idxstack;
        ecaterror: PBoolean;
        DCtime: PInt64;
        SMcommtype: pec_SMcommTypet;
        PDOassign: pec_PDOassignt;
        PDOdesc: pec_PDOdesct;
        eepSM: pec_eepromSM;
        eepFMMU: pec_eepromFMMU;
        FOEhook: ^TFOEhook;
        EOEhook: ^TEOEhook;
        manualstatechange: Integer;
        userdata: Pointer;
    end;

    pec_ODlist = ^ec_Odlist;

    ec_ODlist = record
        Slave: Word;
        Entries: Word;
        Index: array[0..EC_MAXODLIST - 1] of Word;
        DataType: array[0..EC_MAXODLIST - 1] of Word;
        ObjectCode: array[0..EC_MAXODLIST - 1] of Byte;
        MaxSub: array[0..EC_MAXODLIST - 1] of Byte;
        Name: array[0..EC_MAXODLIST - 1] of array[0..EC_MAXNAME] of AnsiChar;
    end;

    pec_OElist = ^ec_OElist;

{+// storage for object list entry information*/ }
    ec_OElist = record
        Entries: Word;
        ValueInfo: array[0..EC_MAXOELIST - 1] of Byte;
        DataType: array[0..EC_MAXOELIST - 1] of Word;
        BitLength: array[0..EC_MAXOELIST - 1] of Word;
        ObjAccess: array[0..EC_MAXOELIST - 1] of Word;
        Name: array[0..EC_MAXOELIST - 1] of array[0..EC_MAXNAME] of AnsiChar;
    end;
const
    ETH_HEADERSIZE = SizeOf(ec_etherheadert);

function dtype2String(dType: Word; Bitlen: Word): string;

implementation

function dtype2String(dType: Word; Bitlen: Word): string;
begin
    case ec_datatype(dType) of
        ECT_BOOLEAN:
            Result := 'BOOLEAN';
        ECT_INTEGER8:
            Result := 'INTEGER8';
        ECT_INTEGER16:
            Result := 'INTEGER16';
        ECT_INTEGER32:
            Result := 'INTEGER32';
        ECT_INTEGER24:
            Result := 'INTEGER24';
        ECT_INTEGER64:
            Result := 'INTEGER64';
        ECT_UNSIGNED8:
            Result := 'UNSIGNED8';
        ECT_UNSIGNED16:
            Result := 'UNSIGNED16';
        ECT_UNSIGNED32:
            Result := 'UNSIGNED32';
        ECT_UNSIGNED24:
            Result := 'UNSIGNED24';
        ECT_UNSIGNED64:
            Result := 'UNSIGNED64';
        ECT_REAL32:
            Result := 'REAL32';
        ECT_REAL64:
            Result := 'REAL64';
        ECT_BIT1:
            Result := 'BIT1';
        ECT_BIT2:
            Result := 'BIT2';
        ECT_BIT3:
            Result := 'BIT3';
        ECT_BIT4:
            Result := 'BIT4';
        ECT_BIT5:
            Result := 'BIT5';
        ECT_BIT6:
            Result := 'BIT6';
        ECT_BIT7:
            Result := 'BIT7';
        ECT_BIT8:
            Result := 'BIT8';
        ECT_VISIBLE_STRING:
            Result := Format('VISIBLE_STR(%d)', [Bitlen]);
        ECT_OCTET_STRING:
            Result := Format('OCTET_STR(%d)', [Bitlen]);
    else
        Result := Format('dt:0x%.4X (%d)', [ord(dType), Bitlen]);
    end;
end;

end.

